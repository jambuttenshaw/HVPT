
// This needs to be first for generated uniform buffer ush to compile
#include "../VoxelGrid/VoxelGridTypes.ush"

#include "/Engine/Private/Common.ush"
#include "../../Shared/HVPTDefinitions.h"

#include "ReSTIRUtils.ush"
#include "PathEvaluation.ush"

#ifndef MULTIPLE_BOUNCES
#define MULTIPLE_BOUNCES true
#endif

uint TemporalSeed;

StructuredBuffer<FHVPT_Reservoir> CurrentReservoirs;
StructuredBuffer<FHVPT_Bounce> ExtraBounces;

StructuredBuffer<uint> ReservoirIndices;

RWTexture2D<float3> RWRadianceTexture;

// Debug tools
uint DebugFlags;
RWTexture2D<float3> RWDebugTexture;


void ReSTIRFinalShading_Main(uint2 PixelCoord, uint ReservoirIndex)
{
	FHVPT_Reservoir Reservoir = CurrentReservoirs[ReservoirIndex];
	
	float3 Radiance = 0.0f;

	if (Reservoir.RunningSum > 0.0f)
	{
		FRayDesc Ray = HVPT_CreateRayDesc(PixelCoord);

		// Ray must be bounded by the HV AABB for tracking to work correctly
		FVolumeIntersection VolIntersect = HVPT_Intersect(Ray.Origin, Ray.Direction, Ray.TMin, Ray.TMax);
		Ray.TMin = VolIntersect.VolumeTMin;
		// If RunningSum > 0, then this ray MUST have intersected with the volume AABB.

		RandomSequence RandSequence = (RandomSequence)0;
		RandomSequence_Initialize(RandSequence, ReservoirIndex, TemporalSeed);

		// Load extra bounces
#if MULTIPLE_BOUNCES
		FHVPT_Bounce Bounces[MAX_EXTRA_BOUNCES];
		uint ExtraBounceIndex = HVPT_GetExtraBounceIndex(PixelCoord, 0);
		for (uint i = 0; i < Reservoir.GetNumExtraBounces(); i++)
		{
			Bounces[i] = ExtraBounces[ExtraBounceIndex + i];
		}
#endif

		Radiance = HVPT_EvaluateF<SHADING_QUALITY_FINAL_SHADING>(Reservoir,
#if MULTIPLE_BOUNCES
			Bounces,
#endif
			Ray, RandSequence);

		float W = Reservoir.P_y == 0.0 ? 1.f : Reservoir.RunningSum / (Reservoir.P_y * Reservoir.M);

		Radiance *= W;
	}

	if (any(or(isnan(Radiance.r), isinf(Radiance.r))))
	{
		Radiance = 0.0f;
	}

	// Transmittance is calculated separately
	RWRadianceTexture[PixelCoord].xyz = Radiance * View.PreExposure;
}

#if USE_DISPATCH_INDIRECT
RAY_TRACING_ENTRY_RAYGEN(ReSTIRFinalShadingRGS)
{
	uint ReservoirIndex = ReservoirIndices[DispatchRaysIndex().x];
	uint2 PixelCoord = HVPT_GetPixelCoord(ReservoirIndex);

	ReSTIRFinalShading_Main(PixelCoord, ReservoirIndex);
}
#else
RAY_TRACING_ENTRY_RAYGEN(ReSTIRFinalShadingRGS)
{
	uint2 PixelCoord = DispatchRaysIndex().xy;
	uint ReservoirIndex = HVPT_GetReservoirIndex(PixelCoord);

	ReSTIRFinalShading_Main(PixelCoord, ReservoirIndex);
}
#endif
