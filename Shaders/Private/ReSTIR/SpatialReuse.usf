
// This needs to be first for generated uniform buffer ush to compile
#include "../VoxelGrid/VoxelGridTypes.ush"

#include "/Engine/Private/Common.ush"
#include "../../Shared/HVPTDefinitions.h"

#include "ReSTIRUtils.ush"
#include "PathEvaluation.ush"
#include "Resampling.ush"

#ifndef MULTIPLE_BOUNCES
#define MULTIPLE_BOUNCES true
#endif

#ifndef MAX_SPATIAL_SAMPLES
#define MAX_SPATIAL_SAMPLES 8
#endif


Texture2D<float> SceneDepthTexture;

uint TemporalSeed;

uint NumSpatialSamples;
float SpatialReuseRadius;
uint bTalbotMIS;

Texture2D<float2> FeatureTexture;

StructuredBuffer<FHVPT_Reservoir> InReservoirs;
StructuredBuffer<FHVPT_Bounce> InExtraBounces;

RWStructuredBuffer<FHVPT_Reservoir> RWOutReservoirs;
RWStructuredBuffer<FHVPT_Bounce> RWOutExtraBounces;

StructuredBuffer<uint> ReservoirIndices;

// Debug tools
uint DebugFlags;
RWTexture2D<float3> RWDebugTexture;


bool IsWithinRange(int2 pos, uint2 range)
{
	return all(pos >= 0) && all(pos < range);
}

int2 GenerateNeighbourhoodOffset(inout RandomSequence RandSequence)
{
	float2 RandValue = RandomSequence_GenerateSample2D(RandSequence);
	return SpatialReuseRadius * UniformSampleDisk(RandValue);
}

#if MULTIPLE_BOUNCES
void LoadExtraBounces(uint ReservoirIndex, uint NumExtraBounces, inout FHVPT_Bounce Bounces[MAX_EXTRA_BOUNCES])
{
	uint ExtraBounceIndex = HVPT_GetExtraBounceIndex(ReservoirIndex, 0);
	for (uint Bounce = 0; Bounce < NumExtraBounces; Bounce++)
	{
		Bounces[Bounce] = InExtraBounces[ExtraBounceIndex + Bounce];
	}
}

void WriteExtraBounces(uint ReservoirIndex, uint NumExtraBounces, FHVPT_Bounce Bounces[MAX_EXTRA_BOUNCES])
{
	uint ExtraBounceIndex = HVPT_GetExtraBounceIndex(ReservoirIndex, 0);
	for (uint Bounce = 0; Bounce < NumExtraBounces; Bounce++)
	{
		RWOutExtraBounces[ExtraBounceIndex + Bounce] = Bounces[Bounce];
	}
}
#endif

void ReSTIRSpatialReuse_Main(uint2 PixelCoord, uint ReservoirIndex)
{
	// Create an empty reservoir to hold the selected path
	FHVPT_Reservoir OutReservoir = HVPT_CreateNewReservoir();
#if MULTIPLE_BOUNCES
	FHVPT_Bounce Bounces[MAX_EXTRA_BOUNCES];
#endif

	RandomSequence RandSequence = (RandomSequence)0;
	RandomSequence_Initialize(RandSequence, ReservoirIndex, TemporalSeed);

	FRayDesc CanonicalRay = HVPT_CreateRayDesc(PixelCoord);

	// Check if pixel should have any volume radiance at all
	if (FeatureTexture[PixelCoord].r == 1.0f)
	{
		OutReservoir = InReservoirs[ReservoirIndex];
		RWOutReservoirs[ReservoirIndex] = OutReservoir;
#if MULTIPLE_BOUNCES
		LoadExtraBounces(ReservoirIndex, OutReservoir.GetNumExtraBounces(), Bounces);
		WriteExtraBounces(ReservoirIndex, OutReservoir.GetNumExtraBounces(), Bounces);
#endif
		return;
	}

	// Including canonical
	uint TotalSampleCount = NumSpatialSamples + 1;
	int2 Offsets[MAX_SPATIAL_SAMPLES + 1];
	Offsets[0] = 0;

	// Generate offsets
	for (uint i = 1; i < TotalSampleCount; i++)
	{
		Offsets[i] = GenerateNeighbourhoodOffset(RandSequence);
	}

	for (uint i = 0; i < TotalSampleCount; i++)
	{
		int2 Offset = Offsets[i];
		int2 TapPos = (int2)PixelCoord + Offset;
		if (IsWithinRange(TapPos, (uint2)View.ViewSizeAndInvSize.xy))
		{
			FHVPT_Reservoir Tap = InReservoirs[HVPT_GetReservoirIndex((uint2)TapPos)];
			if (Tap.M == 0)
				continue;

			float MISWeight = 1.0f;

			if (i > 0) // Don't resample canonical - its already in this domain
			{
#if MULTIPLE_BOUNCES
				LoadExtraBounces(Tap.GetSampledPixel(), Tap.GetNumExtraBounces(), Bounces);
#endif
				HVPT_ResampleNeighbour<SHADING_QUALITY_SPATIAL_REUSE>(Tap, 
#if MULTIPLE_BOUNCES
					Bounces, 
#endif
					CanonicalRay, RandSequence);
			}

			if (bTalbotMIS && Tap.RunningSum > 0.0f)
			{
				float PSum = 0.0f;
				float PQi = 0.0f;
				float K = 0.0f;

				for (int j = 0; j < TotalSampleCount; j++)
				{
					int2 Offset_j = Offsets[j];
					int2 TapPos_j = (int2)PixelCoord + Offset_j;

					if (!IsWithinRange(TapPos_j, View.ViewSizeAndInvSize.xy))
						continue;

					FHVPT_Reservoir Tap_j = InReservoirs[HVPT_GetReservoirIndex((uint2)TapPos_j)];
					if (Tap_j.M == 0)
						continue;

					K += Tap_j.M;

					if (j == 0)
					{
						PQi = Tap.P_y;
						PSum += Tap.P_y * Tap_j.M;
					}
					else if (i == j)
					{
						PQi = Tap_j.P_y;
						PSum += Tap_j.P_y * Tap_j.M;
					}
					else
					{
						FRayDesc NeighbourRay = HVPT_CreateRayDesc(
							CanonicalRay.Origin,
							HVPT_GetRayDirection(TapPos_j)
						);

#if MULTIPLE_BOUNCES
						if (i == 0) LoadExtraBounces(Tap.GetSampledPixel(), Tap.GetNumExtraBounces(), Bounces);
#endif

						float P_y = Luminance(HVPT_EvaluateF<SHADING_QUALITY_SPATIAL_REUSE>(Tap,
#if MULTIPLE_BOUNCES
							Bounces,
#endif
							NeighbourRay,
							RandSequence));
						if (isinf(P_y) || isnan(P_y))
						{
							P_y = 0.0f;
						}
						PSum += P_y * Tap_j.M;
					}
				}

				MISWeight = PSum > 0.0f ? PQi * K / PSum : 0.0f;
			}

			Tap.RunningSum *= MISWeight;
			(void)HVPT_SimpleResampleStep<false>(Tap, OutReservoir, RandomSequence_GenerateSample1D(RandSequence));
		}
	}

	uint ExtraBounceIndex = HVPT_GetExtraBounceIndex(OutReservoir.GetSampledPixel());
	OutReservoir.SetSampledPixel(ReservoirIndex);
	RWOutReservoirs[ReservoirIndex] = OutReservoir;

#if MULTIPLE_BOUNCES
	if (OutReservoir.RunningSum > 0.0f)
	{
		uint OutExtraBounceIndex = HVPT_GetExtraBounceIndex(PixelCoord, 0);
		for (uint Bounce = 0; Bounce < OutReservoir.GetNumExtraBounces(); Bounce++)
		{
			RWOutExtraBounces[OutExtraBounceIndex + Bounce] = InExtraBounces[ExtraBounceIndex + Bounce];
		}
	}
#endif
}


#if USE_DISPATCH_INDIRECT
RAY_TRACING_ENTRY_RAYGEN(ReSTIRSpatialReuseRGS)
{
	uint ReservoirIndex = ReservoirIndices[DispatchRaysIndex().x];
	uint2 PixelCoord = HVPT_GetPixelCoord(ReservoirIndex);

	ReSTIRSpatialReuse_Main(PixelCoord, ReservoirIndex);
}
#else
RAY_TRACING_ENTRY_RAYGEN(ReSTIRSpatialReuseRGS)
{
	uint2 PixelCoord = DispatchRaysIndex().xy;
	uint ReservoirIndex = HVPT_GetReservoirIndex(PixelCoord);

	ReSTIRSpatialReuse_Main(PixelCoord, ReservoirIndex);
}
#endif
