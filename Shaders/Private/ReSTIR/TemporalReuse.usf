
// This needs to be first for generated uniform buffer ush to compile
#include "../VoxelGrid/VoxelGridTypes.ush"

#include "/Engine/Private/Common.ush"
#include "../../Shared/HVPTDefinitions.h"

#include "ReSTIRUtils.ush"
#include "PathEvaluation.ush"
#include "Resampling.ush"

#ifndef MULTIPLE_BOUNCES
#define MULTIPLE_BOUNCES true
#endif

#ifndef ENABLE_TALBOT_MIS
#define ENABLE_TALBOT_MIS true
#endif


Texture2D<float> SceneDepthTexture;
Texture2D<float4> GBufferVelocityTexture;

uint TemporalSeed;

Texture2D<float2> FeatureTexture;
Texture2D<float2> TemporalFeatureTexture;

StructuredBuffer<FHVPT_Reservoir> PreviousReservoirs;
StructuredBuffer<FHVPT_Bounce> PreviousExtraBounces;

RWStructuredBuffer<FHVPT_Reservoir> RWCurrentReservoirs;
RWStructuredBuffer<FHVPT_Bounce> RWCurrentExtraBounces;

float TemporalHistoryThreshold;
uint bEnableTemporalReprojection;

// Debug tools
uint DebugFlags;
RWTexture2D<float3> RWDebugTexture;


#if MULTIPLE_BOUNCES

template<bool bCurrentFrame>
void LoadExtraBounces(uint ReservoirIndex, uint NumBounces, inout FHVPT_Bounce OutBounces[MAX_EXTRA_BOUNCES])
{
	uint Idx = HVPT_GetExtraBounceIndex(ReservoirIndex);
	for (uint Bounce = 0; Bounce < NumBounces; Bounce++)
	{
		if (bCurrentFrame)
		{
			OutBounces[Bounce] = RWCurrentExtraBounces[Idx + Bounce];
		}
		else
		{
			OutBounces[Bounce] = PreviousExtraBounces[Idx + Bounce];
		}
	}
}

void WriteExtraBounces(uint ReservoirIndex, uint NumBounces, FHVPT_Bounce Bounces[MAX_EXTRA_BOUNCES])
{
	uint Idx = HVPT_GetExtraBounceIndex(ReservoirIndex);
	for (uint Bounce = 0; Bounce < NumBounces; Bounce++)
	{
		RWCurrentExtraBounces[Idx + Bounce] = Bounces[Bounce];
	}
}

#endif


float3 ComputePreviousFrameRayDirection(uint2 Pixel)
{
	float2 ScreenPos = float2(Pixel) + HVPT_GetSubpixelJitter();
	float2 ClipPos = float2(2.0f * ScreenPos.x * View.ViewSizeAndInvSize.z - 1, 1 - 2.0f * ScreenPos.y * View.ViewSizeAndInvSize.w);
	float4 ViewPosition = mul(float4(ClipPos, 1, 1), View.PrevClipToView);
	ViewPosition.xyz /= ViewPosition.w;
	float4 TranslatedWorldPosition = mul(ViewPosition, View.PrevViewToTranslatedWorld);

	return normalize(TranslatedWorldPosition.xyz - View.PrevTranslatedWorldCameraOrigin.xyz);
}

float3 GetHistoryScreenPosition(float2 ScreenPosition, float DeviceZ, float ReprojectDeviceZ, float4 EncodedVelocity)
{
	float3 HistoryScreenPosition = float3(ScreenPosition, ReprojectDeviceZ);
	bool bIsDynamicPixel = false;

	{
		float4 ThisClip = float4(HistoryScreenPosition, 1);
		float4 PrevClip = mul(ThisClip, View.ClipToPrevClip); //<=== doesn't contain AA offsets
		
		float3 PrevScreen = PrevClip.xyz / PrevClip.w;
		float3 Velocity = HistoryScreenPosition - PrevScreen;
		bIsDynamicPixel = EncodedVelocity.x > 0.0;

		if (bIsDynamicPixel)
		{
			float4 ReferencePrevClip = mul(float4(ScreenPosition, DeviceZ, 1), View.ClipToPrevClip);
			Velocity += DecodeVelocityFromTexture(EncodedVelocity) - (float3(ScreenPosition, DeviceZ) - ReferencePrevClip.xyz / ReferencePrevClip.w);
		}

		HistoryScreenPosition -= Velocity;
	}

	return HistoryScreenPosition;
}


RAY_TRACING_ENTRY_RAYGEN(ReSTIRTemporalReuseRGS)
{
	uint2 PixelCoord = DispatchRaysIndex().xy;
	uint ReservoirIndex = HVPT_GetReservoirIndex(PixelCoord);

	RandomSequence RandSequence = (RandomSequence)0;
	RandomSequence_Initialize(RandSequence, ReservoirIndex, TemporalSeed);

	FRayDesc CanonicalRay = HVPT_CreateRayDesc(PixelCoord);

	uint NumUsedReservoirs = 1;
	FHVPT_Reservoir Taps[2];
	Taps[0] = RWCurrentReservoirs[ReservoirIndex];

	FHVPT_Reservoir OutReservoir = HVPT_CreateNewReservoir();
#if MULTIPLE_BOUNCES
	FHVPT_Bounce Bounces[MAX_EXTRA_BOUNCES];
#endif

	// TODO: Rename to ReprojectedPixelCoord
	uint2 ReprojectedPixelCoord = PixelCoord;
	uint ReprojectedReservoirIndex = ReservoirIndex;

	float FeatureTransmittance = FeatureTexture[PixelCoord].r;

	// Reprojection
	if (bEnableTemporalReprojection)
	{
		float ReprojectionDepth = Taps[0].GetDepth();
		if (ReprojectionDepth == POSITIVE_INFINITY)
		{
			// Velocity resampling
		}

		// If successfully have sample
		if (ReprojectionDepth != POSITIVE_INFINITY)
		{
			float2 ScreenPos = float2(PixelCoord) + HVPT_GetSubpixelJitter();
			float2 ScreenUV = ScreenPos * View.ViewSizeAndInvSize.zw;
			ScreenPos = float2(2.0f * ScreenUV.x - 1, 1 - 2.0f * ScreenUV.y);
			float DeviceZ = ConvertToDeviceZ(ReprojectionDepth);

			ScreenPos = GetHistoryScreenPosition(ScreenPos, DeviceZ, DeviceZ, GBufferVelocityTexture[PixelCoord]).xy;

			ScreenPos.x = 0.5 * ScreenPos.x + 0.5;
			ScreenPos.y = -0.5 * ScreenPos.y + 0.5;
			ScreenPos *= View.ViewSizeAndInvSize.xy;
			int2 ScreenPosI = int2(ScreenPos + 0.5f);

			if (all(ScreenPosI >= 0) && all(ScreenPosI < View.ViewSizeAndInvSize.xy))
			{
				ReprojectedPixelCoord = uint2(ScreenPosI);
				ReprojectedReservoirIndex = HVPT_GetReservoirIndex(ReprojectedPixelCoord);

				float TemporalFeatureTransmittance = TemporalFeatureTexture[ReprojectedPixelCoord].r;
				if (FeatureTransmittance == 1.0f && TemporalFeatureTransmittance != 1.0f)
				{
					return;
				}
			}
		}
	}

	{
		NumUsedReservoirs++;
		Taps[1] = PreviousReservoirs[HVPT_GetReservoirIndex(ReprojectedPixelCoord)];
	}

	float CurrentM = Taps[0].M;
	float MaxPrevM = TemporalHistoryThreshold * CurrentM;

	// NonCanonicalSampleDepthInPrevFrame: Stores the original depth from last frames reservoir
	// The depth value in the reservoir is then reprojected into this frame and stored in the reservoir
	float NonCanonicalSampleDepthInPrevFrame = 0.0f;
	// Neighbour_P_y: caches the original P_y value in the temporal sample before it is resampled into this domain
	float Neighbour_P_y = 0.0f;

	if (NumUsedReservoirs == 2)
	{
		NonCanonicalSampleDepthInPrevFrame = Taps[1].GetDepth();
		if (NonCanonicalSampleDepthInPrevFrame != POSITIVE_INFINITY)
		{
			float3 Direction = ComputePreviousFrameRayDirection(ReprojectedPixelCoord);
			
			float3 WorldPos = View.PrevTranslatedWorldCameraOrigin + NonCanonicalSampleDepthInPrevFrame * Direction;
			Taps[1].SetDepth(length(WorldPos - CanonicalRay.Origin));
		}

		Neighbour_P_y = Taps[1].P_y;
	}

	// CanonicalSampleDepthInPrevFrame: Take the depth of the canonical sample from this frame.
	// What is the distance from the PREVIOUS view origin to the sample point of this frame
	float CanonicalSampleDepthInPrevFrame = Taps[0].GetDepth();
	if (CanonicalSampleDepthInPrevFrame != POSITIVE_INFINITY)
	{
		float3 WorldPos = CanonicalRay.Origin + CanonicalRay.Direction * CanonicalSampleDepthInPrevFrame;
		CanonicalSampleDepthInPrevFrame = length(WorldPos - View.PrevTranslatedWorldCameraOrigin);
	}

	bool HasSelection = false;
	uint SelectedId = (uint) -1;

	for (uint i = 0; i < NumUsedReservoirs; i++)
	{
		float MISWeight = 1.0f;
		if (Taps[i].M == 0)
			continue;

		if (Taps[i].P_y > 0.0f)
		{
			if (isnan(Taps[i].RunningSum) || isinf(Taps[i].RunningSum))
				Taps[i].RunningSum = 0.0f;

			if (i > 0)
			{
				// Resample temporal sample in the canonical (this frame's) domain
#if MULTIPLE_BOUNCES
				LoadExtraBounces<false>(ReprojectedReservoirIndex, Taps[i].GetNumExtraBounces(), Bounces);
#endif
				HVPT_ResampleNeighbour<SHADING_QUALITY_TEMPORAL_REUSE>(Taps[i], 
#if MULTIPLE_BOUNCES
					Bounces,
#endif
					CanonicalRay,
					RandSequence);
			}
		}
		else
		{
			Taps[i].P_y = 0.0f;
			Taps[i].RunningSum = 0.0f;
		}

#if ENABLE_TALBOT_MIS
		// Calculate MIS weight
		if (Taps[i].RunningSum > 0.0f)
		{
			float PSum = 0.0f;
			float PQi = 0.0f;
			float K = 0.0f;

			for (uint j = 0; j < NumUsedReservoirs; j++)
			{
				// Select domain
				uint2 TapPos_j = (j == 0) ? PixelCoord : ReprojectedPixelCoord;
				float CorrectedM = min(MaxPrevM, Taps[j].M);

				K += CorrectedM;

				if (j == 0) // Canonical sample in canonical domain
				{
					PQi = Taps[i].P_y;
					PSum += Taps[i].P_y * CorrectedM;
				}
				else if (i == j) // Temporal sample in temporal domain
				{
					PQi = Neighbour_P_y;
					PSum += Neighbour_P_y * CorrectedM;
				}
				else // resample in neighbours domain (canonical in temporal and temporal in canonical)
				{
					// Create camera ray using previous frames camera properties
					FRayDesc ReprojectedRay = HVPT_CreateRayDesc(
						View.PrevTranslatedWorldCameraOrigin, 
						ComputePreviousFrameRayDirection(TapPos_j)
					);

					float UsedDepth = (i == 0) // Note: j is always 1 in this branch
									? CanonicalSampleDepthInPrevFrame		// Canonical sample in temporal domain
									: NonCanonicalSampleDepthInPrevFrame;	// Temporal sample in canonical domain
					float BackupDepth = Taps[i].GetDepth();
					Taps[i].SetDepth(UsedDepth);

#if MULTIPLE_BOUNCES
					if (i == 0)
					{
						LoadExtraBounces<true>(ReservoirIndex, Taps[i].GetNumExtraBounces(), Bounces);
					}
					else
					{
						LoadExtraBounces<false>(ReprojectedReservoirIndex, Taps[i].GetNumExtraBounces(), Bounces);
					}
#endif

					float P_y = Luminance(HVPT_EvaluateF<SHADING_QUALITY_TEMPORAL_REUSE>(Taps[i],
#if MULTIPLE_BOUNCES
						Bounces,
#endif
						ReprojectedRay,
						RandSequence));

					Taps[i].SetDepth(BackupDepth);
					if (isinf(P_y) || isnan(P_y))
					{
						P_y = 0.0f;
					}
					PSum += P_y * CorrectedM;
				}
			}

			MISWeight = PSum > 0.0f ? PQi * K / PSum : 0.0f;
		}
#endif

		Taps[i].RunningSum *= MISWeight;

		if (HVPT_SimpleResampleStep<true>(Taps[i], OutReservoir, RandomSequence_GenerateSample1D(RandSequence), MaxPrevM))
		{
			SelectedId = i;
			HasSelection = true;
		}
	}

	uint ExtraBouncePixelIndex = OutReservoir.GetSampledPixel();
	OutReservoir.SetSampledPixel(ReservoirIndex);

	RWCurrentReservoirs[ReservoirIndex] = OutReservoir;

#if MULTIPLE_BOUNCES
	if (HasSelection && SelectedId > 0)
	{
		LoadExtraBounces<false>(ExtraBouncePixelIndex, OutReservoir.GetNumExtraBounces(), Bounces);
		WriteExtraBounces(ExtraBouncePixelIndex, OutReservoir.GetNumExtraBounces(), Bounces);
	}
#endif

#if DEBUG_OUTPUT_ENABLED
	if ((DebugFlags & 0xFF) == HVPT_DEBUG_VIEW_MODE_TEMPORAL_REUSE)
	{
		RWDebugTexture[PixelCoord] = (SelectedId == 0) ? float3(1, 0, 0) : float3(0, 1, 0);
	}
	else if ((DebugFlags & 0xFF) == HVPT_DEBUG_VIEW_MODE_REPROJECTION)
	{
		// Saturates at 25 pixel radius
		float2 Diff = (float2(ReprojectedPixelCoord) - float2(PixelCoord)) / 25.0f;
		RWDebugTexture[PixelCoord] = float3(saturate(Diff * 0.5f + 0.5f), 0);
	}
#endif
}
