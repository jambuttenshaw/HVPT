#ifndef RESTIRUTILS_H
#define RESTIRUTILS_H

#include "../../Shared/HVPTDefinitions.h"

#include "../Utils/PathTracingUtils.ush"

#ifndef MULTIPLE_BOUNCES
#define MULTIPLE_BOUNCES true
#endif


RaytracingAccelerationStructure TLAS;

// The currently set max number of bounces a ray can take. Must never be greater than kReSTIRMaxBounces
uint NumBounces;

//
// --- MISC HELPER FUNCTIONS ---
//

uint HVPT_GetReservoirIndex(uint2 PixelCoord)
{
	return PixelCoord.y * View.ViewSizeAndInvSize.x + PixelCoord.x;
}

uint HVPT_GetExtraBounceIndex(uint2 PixelCoord, uint Bounce = 0)
{
	return (HVPT_GetReservoirIndex(PixelCoord) * (NumBounces - 1)) + Bounce;
}

float3 HVPT_GetRayDirection(uint2 PixelCoord)
{
	float2 ScreenPos = float2(PixelCoord) + HVPT_GetSubpixelJitter();
	float4 TranslatedWorldPosition = mul(float4(ScreenPos, 1, 1), View.SVPositionToTranslatedWorld);
	TranslatedWorldPosition.xyz /= TranslatedWorldPosition.w;

	return GetCameraVectorFromTranslatedWorldPosition(TranslatedWorldPosition.xyz);
}

//
// --- RESERVOIR HELPER FUNCTIONS ---
//

bool HVPT_UpdateReservoir(inout FHVPT_Reservoir Reservoir, float p, float p_hat, float RandValue)
{
	// Handle null samples
	if (p == 0.0f)
	{
		Reservoir.M++;
		return false;
	}

	float w = p_hat / p;
	Reservoir.RunningSum += w;
	Reservoir.M++;

	if (RandValue < w / Reservoir.RunningSum)
	{
		Reservoir.P_y = p_hat;
		return true;
	}

	return false;
}

template<bool bThresholdM=false>
bool HVPT_CombineReservoirs(inout FHVPT_Reservoir Reservoir, FHVPT_Reservoir r_i, float p_hat, float m, float RandValue, float ThresholdM = 0.0f)
{
	float weight = (p_hat / r_i.P_y);
	if (isinf(weight) || isnan(weight))
		weight = 0.0f;
	Reservoir.RunningSum *= weight * m;

	float CorrectedM, SampleWeight;
	if (bThresholdM)
	{
		CorrectedM = min(ThresholdM, r_i.M);
		SampleWeight = CorrectedM == 0.0f ? 0.0f : CorrectedM / r_i.M * r_i.RunningSum;
	}
	else
	{
		CorrectedM = r_i.M;
		SampleWeight = r_i.RunningSum;
	}

	Reservoir.M += CorrectedM;

	// Handle null samples
	if (SampleWeight == 0.0f)
	{
		return false;
	}

	float w = SampleWeight;

	Reservoir.RunningSum += w;

	if (RandValue < w / SampleWeight)
	{
		Reservoir.P_y = p_hat;
		return true;
	}

	return false;
}


FHVPT_Reservoir HVPT_CreateNewReservoir()
{
	FHVPT_Reservoir OutReservoir = (FHVPT_Reservoir)0;
	OutReservoir.RunningSum = 0.0f;
	OutReservoir.M = 0.0f;
	OutReservoir.P_y = 0.0f;
	OutReservoir.bEmissionPath = false;
	OutReservoir.Depth = POSITIVE_INFINITY;
	OutReservoir.LightId = -1;
	OutReservoir.LightSample = 0.0f;
	OutReservoir.NumExtraBounces = 0;
	OutReservoir.SampledPixel = 0;
	return OutReservoir;
}

template<bool bThresholdM>
bool HVPT_SimpleResampleStep(FHVPT_Reservoir Reservoir, inout FHVPT_Reservoir State, float RandValue, float MThreshold = 0.0f)
{
	float CorrectedM, SampleWeight;
	if (bThresholdM)
	{
		CorrectedM = min(MThreshold, Reservoir.M);
		SampleWeight = CorrectedM == 0.0f ? 0.0f : CorrectedM / Reservoir.M * Reservoir.RunningSum;
	}
	else
	{
		CorrectedM = Reservoir.M;
		SampleWeight = Reservoir.RunningSum;
	}
	
    State.M += CorrectedM;
    if (SampleWeight <= 0.0f) return false;

    // Update the weight
	State.RunningSum += SampleWeight;

	bool bSelectSample = RandValue * State.RunningSum < SampleWeight;

    // If we did select this sample, update the relevant data
	State.P_y			  = bSelectSample ? Reservoir.P_y			  : State.P_y;
	State.bEmissionPath   =	bSelectSample ? Reservoir.bEmissionPath	  : State.bEmissionPath;
	State.Depth			  =	bSelectSample ? Reservoir.Depth			  : State.Depth;
	State.LightId		  =	bSelectSample ? Reservoir.LightId		  : State.LightId;
	State.LightSample	  =	bSelectSample ? Reservoir.LightSample	  : State.LightSample;
	State.NumExtraBounces = bSelectSample ? Reservoir.NumExtraBounces : State.NumExtraBounces;
	State.SampledPixel	  =	bSelectSample ? Reservoir.SampledPixel	  : State.SampledPixel;

    return bSelectSample;
}

#endif