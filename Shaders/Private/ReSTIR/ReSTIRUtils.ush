#ifndef RESTIRUTILS_H
#define RESTIRUTILS_H

#include "../../Shared/HVPTDefinitions.h"

#include "/Engine/Private/OctahedralCommon.ush"
#include "../Utils/PathTracingUtils.ush"

#ifndef MULTIPLE_BOUNCES
#define MULTIPLE_BOUNCES true
#endif


RaytracingAccelerationStructure TLAS;

// The currently set max number of bounces a ray can take. Must never be greater than kReSTIRMaxBounces
uint NumBounces;

//
// --- MISC HELPER FUNCTIONS ---
//

uint HVPT_GetReservoirIndex(uint2 PixelCoord)
{
	return PixelCoord.y * View.ViewSizeAndInvSize.x + PixelCoord.x;
}

uint2 HVPT_GetPixelCoord(uint ReservoirIndex)
{
	return uint2(ReservoirIndex % View.ViewSizeAndInvSize.x, ReservoirIndex / View.ViewSizeAndInvSize.x);
}

uint HVPT_GetExtraBounceIndex(uint2 PixelCoord, uint Bounce = 0)
{
	return HVPT_GetReservoirIndex(PixelCoord) * (NumBounces - 1) + Bounce;
}

uint HVPT_GetExtraBounceIndex(uint ReservoirIndex, uint Bounce = 0)
{
	return ReservoirIndex * (NumBounces - 1) + Bounce;
}

float3 HVPT_GetRayDirection(uint2 PixelCoord)
{
	float2 ScreenPos = float2(PixelCoord) + HVPT_GetSubpixelJitter();
	float4 TranslatedWorldPosition = mul(float4(ScreenPos, 1, 1), View.SVPositionToTranslatedWorld);
	TranslatedWorldPosition.xyz /= TranslatedWorldPosition.w;

	return GetCameraVectorFromTranslatedWorldPosition(TranslatedWorldPosition.xyz);
}

//
// --- BOUNCE HELPERS ---
//

void HVPT_EncodeBounce(out FHVPT_Bounce Bounce, float3 Direction, float Distance)
{
	float2 OctahedronDirection = UnitVectorToOctahedron(Direction);
	Bounce.PackedData.x = (f32tof16(OctahedronDirection.x) << 16) | f32tof16(OctahedronDirection.y);
	Bounce.PackedData.y = asuint(Distance);
}

float4 HVPT_DecodeBounce(FHVPT_Bounce Bounce)
{
	float4 Out;
	Out.xyz = OctahedronToUnitVector(float2(f16tof32(Bounce.PackedData.x >> 16), f16tof32(Bounce.PackedData.x)));
	Out.w = asfloat(Bounce.PackedData.y);
	return Out;
}


void HVPT_SurfaceBounce_SetPackedData(inout FHVPT_DeferredSurfaceBounce SurfaceBounce, uint ReservoirIndex, uint NumExtraBounces)
{
	SurfaceBounce.PackedData = ReservoirIndex << 4 | (NumExtraBounces & 0x00000003) << 1;
}

void HVPT_SurfaceBounce_GetPackedData(FHVPT_DeferredSurfaceBounce SurfaceBounce, out uint ReservoirIndex, out uint NumExtraBounces)
{
	ReservoirIndex = SurfaceBounce.PackedData >> 4;
	NumExtraBounces = (SurfaceBounce.PackedData >> 1) & 0x00000003;
}

void HVPT_SurfaceBounce_SetPackedDirection(inout FHVPT_DeferredSurfaceBounce SurfaceBounce, float3 Direction)
{
	float2 OctahedronDirection = UnitVectorToOctahedron(Direction);
	SurfaceBounce.PackedDirection = (f32tof16(OctahedronDirection.x) << 16) | f32tof16(OctahedronDirection.y);
}

float3 HVPT_SurfaceBounce_GetPackedDirection(FHVPT_DeferredSurfaceBounce SurfaceBounce)
{
	return OctahedronToUnitVector(float2(f16tof32(SurfaceBounce.PackedDirection.x >> 16), f16tof32(SurfaceBounce.PackedDirection.x)));
}

//
// --- RESERVOIR HELPER FUNCTIONS ---
//

FHVPT_Reservoir HVPT_CreateNewReservoir()
{
	FHVPT_Reservoir OutReservoir = (FHVPT_Reservoir)0;
	OutReservoir.RunningSum = 0.0f;
	OutReservoir.M = 0.0f;
	OutReservoir.P_y = 0.0f;
	OutReservoir.PackedData[0] = 0;
	OutReservoir.SetDepth(POSITIVE_INFINITY);
	OutReservoir.SetLightId(-1);
	OutReservoir.LightSample = 0.0f;
	return OutReservoir;
}

template<bool bThresholdM>
bool HVPT_SimpleResampleStep(FHVPT_Reservoir Reservoir, inout FHVPT_Reservoir State, float RandValue, float MThreshold = 0.0f)
{
	float CorrectedM, SampleWeight;
	if (bThresholdM)
	{
		CorrectedM = min(MThreshold, Reservoir.M);
		SampleWeight = CorrectedM / Reservoir.M * Reservoir.RunningSum;
	}
	else
	{
		CorrectedM = Reservoir.M;
		SampleWeight = Reservoir.RunningSum;
	}
	
    State.M += CorrectedM;
    if (SampleWeight <= 0.0f) return false;

    // Update the weight
	State.RunningSum += SampleWeight;

	bool bSelectSample = RandValue * State.RunningSum < SampleWeight;

    // If we did select this sample, update the relevant data
	State.P_y			= bSelectSample ? Reservoir.P_y			  : State.P_y;
	State.PackedData[0] = bSelectSample ? Reservoir.PackedData[0] : State.PackedData[0];
	State.PackedData[1] = bSelectSample ? Reservoir.PackedData[1] : State.PackedData[1];
	State.LightSample	= bSelectSample ? Reservoir.LightSample	  : State.LightSample;

    return bSelectSample;
}

#endif