#ifndef RESTIRUTILS_H
#define RESTIRUTILS_H

#include "../../Shared/HVPTDefinitions.h"

#include "../Utils/PathTracingUtils.ush"


RaytracingAccelerationStructure TLAS;

// The currently set max number of bounces a ray can take. Must never be greater than kReSTIRMaxBounces
uint NumBounces;

//
// --- MISC HELPER FUNCTIONS ---
//

uint HVPT_GetReservoirIndex(uint2 PixelCoord)
{
	return PixelCoord.y * View.ViewSizeAndInvSize.x + PixelCoord.x;
}

uint HVPT_GetExtraBounceIndex(uint2 PixelCoord, uint Bounce)
{
	return (HVPT_GetReservoirIndex(PixelCoord) * (NumBounces - 1)) + Bounce;
}

float3 HVPT_GetRayDirection(uint2 PixelCoord)
{
	float2 ScreenPos = float2(PixelCoord) + HVPT_GetSubpixelJitter();
	float4 TranslatedWorldPosition = mul(float4(ScreenPos, 1, 1), View.SVPositionToTranslatedWorld);
	TranslatedWorldPosition.xyz /= TranslatedWorldPosition.w;

	return GetCameraVectorFromTranslatedWorldPosition(TranslatedWorldPosition.xyz);
}

//
// --- RESERVOIR HELPER FUNCTIONS ---
//

bool HVPT_UpdateReservoir(inout FHVPT_Reservoir Reservoir, float p, float p_hat, float RandValue)
{
	// Handle null samples
	if (p == 0.0f)
	{
		Reservoir.M++;
		return false;
	}

	float w = p_hat / p;
	Reservoir.RunningSum += w;
	Reservoir.M++;

	if (RandValue < w / Reservoir.RunningSum)
	{
		Reservoir.P_y = p_hat;
		return true;
	}

	return false;
}

template<bool bThresholdM=false>
bool HVPT_CombineReservoirs(inout FHVPT_Reservoir Reservoir, FHVPT_Reservoir r_i, float p_hat, float m, float RandValue, float ThresholdM = 0.0f)
{
	float weight = (p_hat / r_i.P_y);
	if (isinf(weight) || isnan(weight))
		weight = 0.0f;
	Reservoir.RunningSum *= weight * m;

	float CorrectedM, SampleWeight;
	if (bThresholdM)
	{
		CorrectedM = min(ThresholdM, r_i.M);
		SampleWeight = CorrectedM == 0.0f ? 0.0f : CorrectedM / r_i.M * r_i.RunningSum;
	}
	else
	{
		CorrectedM = r_i.M;
		SampleWeight = r_i.RunningSum;
	}

	Reservoir.M += CorrectedM;

	// Handle null samples
	if (SampleWeight == 0.0f)
	{
		return false;
	}

	float w = SampleWeight;

	Reservoir.RunningSum += w;

	if (RandValue < w / SampleWeight)
	{
		Reservoir.P_y = p_hat;
		return true;
	}

	return false;
}

#endif