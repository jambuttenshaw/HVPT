
// This needs to be first for generated uniform buffer ush to compile
#include "../VoxelGrid/VoxelGridTypes.ush"

#include "/Engine/Private/Common.ush"
#include "/Engine/Private/RayTracing/RayTracingCommon.ush"
#include "/Engine/Private/PathTracing/Volume/PathTracingVolumeCommon.ush"

#include "../../Shared/HVPTDefinitions.h"

#include "ReSTIRUtils.ush"
#include "PathEvaluation.ush"


#ifndef MULTIPLE_BOUNCES
#define MULTIPLE_BOUNCES true
#endif

#ifndef USE_SURFACE_CONTRIBUTIONS
#define USE_SURFACE_CONTRIBUTIONS true
#endif

// Uses a copy of the scene depth, that was made before writing HVPT into it
Texture2D<float> SceneDepthTexture_Copy;
Texture2D<float2> FeatureTexture;

uint TemporalSeed;

uint NumInitialCandidates;
uint bUseShadowTermForCandidateGeneration;

RWStructuredBuffer<FHVPT_Reservoir> RWCurrentReservoirs;
RWStructuredBuffer<FHVPT_Bounce> RWExtraBounces;

StructuredBuffer<uint> ReservoirIndices;

// Debug tools
uint DebugFlags;
RWTexture2D<float3> RWDebugTexture;


#if USE_SURFACE_CONTRIBUTIONS
float3 SampleDirectLightingSurface(
	FRayDesc Ray, 
	FPathTracingPayload Payload,
	inout RandomSequence RandSequence, 
	out float OutLightPDF, 
	out uint OutLightId, 
	out float2 OutLightSample
)
{
	// Pick a light source to sample
	float3 LightRandValue = RandomSequence_GenerateSample3D(RandSequence);
	FLightSample LightSample = HVPT_SampleLight(Payload.TranslatedWorldPos, Payload.WorldNormal, LightRandValue, OutLightId);
	if (LightSample.Pdf <= 0.0f)
	{
		OutLightPDF = 0.0f;
		return 0.0f;
	}

	FMaterialEval MaterialEval = EvalMaterial(-Ray.Direction, LightSample.Direction, Payload, float2(1.0f, 0.0f));
	float3 Ld = MaterialEval.Weight * LightSample.RadianceOverPdf;
	if (bUseShadowTermForCandidateGeneration)
	{
		Ld *= HVPT_CalculateLightVisibility<SHADING_QUALITY_CANDIDATE_GENERATION>(Payload.TranslatedWorldPos, LightSample, RandSequence);
	}

	OutLightPDF = LightSample.Pdf;
	OutLightSample = LightRandValue.yz;
	return Ld;
}
#endif


float3 SampleDirectLighting(
	FRayDesc Ray,
	FHVPT_TrackingResult TrackingResult,
	float3 TranslatedWorldPos,
	inout RandomSequence RandSequence,
	out float OutLightPDF,
	out uint OutLightId,
	out float2 OutLightSample
)
{
	// Pick a light source to sample
	float3 LightRandValue = RandomSequence_GenerateSample3D(RandSequence);
	FLightSample LightSample = HVPT_SampleLight(TranslatedWorldPos, 0.0f, LightRandValue, OutLightId);
	if (LightSample.Pdf <= 0.0f)
	{
		OutLightPDF = 0.0f;
		return 0.0f;
	}

	float Phase = HenyeyGreensteinPhase(TrackingResult.PhaseG, dot(-Ray.Direction, LightSample.Direction));
	float3 Ld = Phase * LightSample.RadianceOverPdf;
	if (bUseShadowTermForCandidateGeneration)
	{
		Ld *= HVPT_CalculateLightVisibility<SHADING_QUALITY_CANDIDATE_GENERATION>(TranslatedWorldPos, LightSample, RandSequence);
	}

	OutLightPDF = LightSample.Pdf;
	OutLightSample = LightRandValue.yz;
	return Ld;
}


FHVPT_Reservoir ComputeInitialSample(
	FRayDesc Ray,
#if MULTIPLE_BOUNCES
	inout FHVPT_Bounce ExtraBounces[MAX_EXTRA_BOUNCES],
#endif
	inout RandomSequence RandSequence
)
{
	float PathPDF = 1.0f;
	float PathPHat = 1.0f;

#if MULTIPLE_BOUNCES
	// If single bounce, then only 1 reservoir will be produced so no need for a reservoir to accumulate into
	FHVPT_Reservoir CombinedReservoir = HVPT_CreateNewReservoir();
	float PrimaryScatterDepth = 0.0f;

	// Flags when ray hit nothing that the ray can bounce off of, stops processing of the candidate
	// In single-bounce setup, no loop occurs anyway so no loop to break out of
	bool bHitEmpty = false;
#endif

	FHVPT_Reservoir OutReservoir;

	for (uint Bounce = 0; Bounce < NumBounces; Bounce++)
	{
		OutReservoir = HVPT_CreateNewReservoir();
		OutReservoir.M = 1;

		FHVPT_TrackingResult TrackingResult = (FHVPT_TrackingResult)0;
		bool bVolumeInteractionValid = true;

#if MULTIPLE_BOUNCES
		// Check the ray that was generated intersects with the volume bounding box,
		// and critically, clip the ray extent. Failing to clip the rays extent can cause TDR downstream
		FVolumeIntersection VolIntersect = HVPT_Intersect(Ray.Origin, Ray.Direction, Ray.TMin, Ray.TMax);
		if (VolIntersect.HitVolume())
		{
			Ray.TMin = max(Ray.TMin, VolIntersect.VolumeTMin);
			Ray.TMax = min(Ray.TMax, VolIntersect.VolumeTMax);
#endif
			// Perform tracking to get a distance into the volume
			TrackingResult = HVPT_DeltaTracking(Ray, RandSequence);
			bVolumeInteractionValid &= TrackingResult.Distance != POSITIVE_INFINITY;
#if MULTIPLE_BOUNCES
		}
		else
		{
			// Unlikely (potentially impossible?) to hit
			bVolumeInteractionValid = false;
			TrackingResult.Distance = POSITIVE_INFINITY;
		}
#endif

		// Add vertex to path
		if (Bounce == 0)
		{
			OutReservoir.SetDepth(TrackingResult.Distance); // If tracking did not intersect volume then distance will be POSITIVE_INFINITY anyway
#if MULTIPLE_BOUNCES
			PrimaryScatterDepth = TrackingResult.Distance;
		}
		else
		{
			OutReservoir.SetDepth(PrimaryScatterDepth);
			OutReservoir.SetNumExtraBounces(Bounce);
			HVPT_EncodeBounce(ExtraBounces[Bounce - 1], Ray.Direction, TrackingResult.Distance);
#endif
		}

		if (bVolumeInteractionValid)
		{
			float PDFDist = Luminance(TrackingResult.SigmaT * TrackingResult.Transmittance);
			PathPHat *= PDFDist;
			PathPDF *= PDFDist;

			float3 TranslatedWorldPos = Ray.Origin + TrackingResult.Distance * Ray.Direction;

			// PDF used for this reservoir only
			// We need to retain PathPDF for subsequent bounces (which will be different reservoirs)
			float CandidatePDF = PathPDF;

			// Absorption ratio
			float3 Albedo = TrackingResult.SigmaS / TrackingResult.SigmaT;
			float3 OneMinusAlbedo = 1.0f - Albedo;

			float OutLightPDF = 0.0f;
			uint LightId = -1;
			float3 Ld = SampleDirectLighting(
				Ray, TrackingResult, TranslatedWorldPos, RandSequence, OutLightPDF, LightId, OutReservoir.LightSample
			);
			float3 Le = TrackingResult.Emission;

			// Perform RIS step between emission and in-scattering
			float EmissionWeight = Luminance(OneMinusAlbedo * Le);
			float EmissionRatio = EmissionWeight / (EmissionWeight + Luminance(Albedo * Ld));
			if (isnan(EmissionRatio))
				EmissionRatio = 0.0f;

			if (RandomSequence_GenerateSample1D(RandSequence) < EmissionRatio)
			{
				// Emission was selected
				CandidatePDF *= EmissionRatio;
				OutReservoir.SetEmissionPath(true);
			}
			else
			{
				// Scattering was selected
				CandidatePDF *= OutLightPDF * (1.0f - EmissionRatio);
				OutReservoir.SetLightId(LightId);
			}

			// Calculate target function for this sample
			// If PDF is 0 then no problem - OutReservoir.RunningSum will be 0 and this reservoir will not be chosen
			if (CandidatePDF > 0.0f)
			{
				if (OutReservoir.GetEmissionPath())
				{
					float3 SigmaA = TrackingResult.SigmaT - TrackingResult.SigmaS;
					OutReservoir.P_y = PathPHat * Luminance(SigmaA * Le);
				}
				else
				{
					// Ld is pre-divided by PDF
					OutReservoir.P_y = PathPHat * Luminance(TrackingResult.SigmaS * Ld * OutLightPDF);
				}

				// Calculate weight for this sample
				OutReservoir.RunningSum = OutReservoir.P_y / CandidatePDF;
			}

#if MULTIPLE_BOUNCES
			// Select new direction for ray to bounce in
			if (NumBounces > 1 && Bounce < NumBounces - 1)
			{
				// Sample phase function for new scattering direction
				float4 DirectionAndPDF = ImportanceSampleHenyeyGreensteinPhase(RandomSequence_GenerateSample2D(RandSequence), TrackingResult.PhaseG);
				float3 wi = TangentToWorld(DirectionAndPDF.xyz, Ray.Direction);
				float PDFDir = DirectionAndPDF.w;

				PathPHat *= Luminance(TrackingResult.SigmaS) * PDFDir;
				PathPDF *= PDFDir;

				// Create a new ray pointing in the sampled direction
				Ray = HVPT_CreateRayDesc(TranslatedWorldPos, wi);
			}
#endif
		}
// In practice, surface contributions only work in multi-bounce setup
#if MULTIPLE_BOUNCES && USE_SURFACE_CONTRIBUTIONS
		else if (Bounce > 0)
		{
			FRayDesc SurfaceRay = Ray;
			SurfaceRay.TMin = 0.0f;
			SurfaceRay.TMax = POSITIVE_INFINITY;
			FRayCone RayCone = (FRayCone)0;
			FMaterialClosestHitPayload HitInfo = HVPT_TraceMaterialRay(
				TLAS,
				0,
				PATHTRACER_MASK_ALL,
				SurfaceRay,
				RayCone,
				false,
				true,
				true
			);
			if (HitInfo.IsHit())
			{
				FPathTracingPayload Payload = HVPT_CreateSurfaceHitPayload(HitInfo);

				// Hit surface - find candidate paths that either sample emissive surface or sample direct light that bounces off surface
				// In path evaluation, surface hit is denoted by Distance == POSITIVE_INFINITY

				float3 Albedo = Payload.GetBaseColor();
				float3 OneMinusAlbedo = 1.0f - Albedo;

				float OutLightPDF = 0.0f;
				uint LightId = -1;
				float3 Ld = SampleDirectLightingSurface(
					Ray, Payload, RandSequence, OutLightPDF, LightId, OutReservoir.LightSample
				);
				float3 Le = Payload.Radiance;

				// Perform RIS step between emission and in-scattering
				float EmissionWeight = Luminance(OneMinusAlbedo * Le);
				float EmissionRatio = EmissionWeight / (EmissionWeight + Luminance(Albedo * Ld));
				if (isnan(EmissionRatio))
					EmissionRatio = 0.0f;
					
				bool bEmissionPath = RandomSequence_GenerateSample1D(RandSequence) < EmissionRatio;
				PathPDF *= bEmissionPath ? EmissionRatio : OutLightPDF * (1.0f - EmissionRatio);

				// Calculate target function for this sample
				// If PDF is 0 then no problem - OutReservoir.RunningSum will be 0 and this reservoir will not be chosen
				if (PathPDF > 0.0f)
				{
					OutReservoir.P_y = PathPHat * Luminance(OutReservoir.GetEmissionPath() ? Le : Ld * OutLightPDF);
					OutReservoir.RunningSum = OutReservoir.P_y / PathPDF;
					OutReservoir.SetEmissionPath(bEmissionPath);
					OutReservoir.SetLightId(LightId);
				}
			}

			// Whether surface hit was encountered or not, we do not want to bounce the ray off of a surface
			bHitEmpty = true;
		}
#endif
#if MULTIPLE_BOUNCES
		else
		{
			bHitEmpty = true;
		}
#endif

#if MULTIPLE_BOUNCES
		HVPT_SimpleResampleStep<false>(OutReservoir, CombinedReservoir, RandomSequence_GenerateSample1D(RandSequence));
		if (bHitEmpty)
			break;
#endif
	}

#if MULTIPLE_BOUNCES
	CombinedReservoir.M = 1;
	return CombinedReservoir;
#else
	return OutReservoir;
#endif
}


void ReSTIRCandidateGeneration_Main(uint2 PixelCoord, uint ReservoirIndex)
{
	FHVPT_Reservoir FinalReservoir = HVPT_CreateNewReservoir();

	// We have already performed a prepass that determines if any media exists for this pixel
	// - if there is no media, there is no point attempting to produce candidates
	if (FeatureTexture[PixelCoord].r == 1.0f)
	{
		// Output an empty reservoir
		RWCurrentReservoirs[ReservoirIndex] = FinalReservoir;
		return;
	}

#if MULTIPLE_BOUNCES
	FHVPT_Bounce FinalExtraBounces[MAX_EXTRA_BOUNCES];
#endif

	// Get ray origin and direction
	float DeviceZ = SceneDepthTexture_Copy.Load(uint3(PixelCoord, 0)).r;
	FRayDesc PrimaryRay = HVPT_CreateRayDesc<true>(PixelCoord, DeviceZ);

	// Find extents of intersection with volume bounding box (if FeatureTexture transmittance < 1, we must have intersected the volume)
	FVolumeIntersection VolIntersect = HVPT_Intersect(PrimaryRay.Origin, PrimaryRay.Direction, PrimaryRay.TMin, PrimaryRay.TMax);
	PrimaryRay.TMin = VolIntersect.VolumeTMin;
	PrimaryRay.TMax = VolIntersect.VolumeTMax;

	// Create random sequence
	RandomSequence RandSequence = (RandomSequence)0;
	uint LinearPixelIndex = PixelCoord.y * View.ViewSizeAndInvSize.x + PixelCoord.x;
	RandomSequence_Initialize(RandSequence, LinearPixelIndex, TemporalSeed);

	// Create initial samples
	for (uint m = 0; m < NumInitialCandidates; m++)
	{
#if MULTIPLE_BOUNCES
		FHVPT_Bounce OutBounces[MAX_EXTRA_BOUNCES];
#endif

		FHVPT_Reservoir OutReservoir = ComputeInitialSample(PrimaryRay, 
#if MULTIPLE_BOUNCES
			OutBounces, 
#endif
			RandSequence);

		bool bSelected = HVPT_SimpleResampleStep<false>(OutReservoir, FinalReservoir, RandomSequence_GenerateSample1D(RandSequence));
#if MULTIPLE_BOUNCES
		if (bSelected)
		{
			for (uint Bounce = 0; Bounce < FinalReservoir.GetNumExtraBounces(); Bounce++)
			{
				FinalExtraBounces[Bounce] = OutBounces[Bounce];
			}
		}
#endif
	} // For each initial candidate

	// Store the sampled pixel in the reservoir, this is used to later retrieve its extra bounces
	FinalReservoir.SetReservoirIndex(ReservoirIndex);

#if !(DEFER_EVALUATE_F)
	// Evaluate PHat
	if (FinalReservoir.RunningSum > 0.0f)
	{
		float PHat = Luminance(HVPT_EvaluateF<SHADING_QUALITY_CANDIDATE_GENERATION>(FinalReservoir,
#if MULTIPLE_BOUNCES
			FinalExtraBounces,
#endif
			PrimaryRay, RandSequence));
		FinalReservoir.RunningSum *= (FinalReservoir.P_y == 0.0f) ? 0.0f : PHat / FinalReservoir.P_y;
		FinalReservoir.P_y = PHat;
	}
#endif

	// Output reservoir
	RWCurrentReservoirs[ReservoirIndex] = FinalReservoir;

#if MULTIPLE_BOUNCES
	// Output bounces
	uint ExtraBounceIndex = HVPT_GetExtraBounceIndex(PixelCoord, 0);
	for (uint i = 0; i < FinalReservoir.GetNumExtraBounces(); i++)
	{
		RWExtraBounces[ExtraBounceIndex + i] = FinalExtraBounces[i];
	}
#endif
}

#if USE_DISPATCH_INDIRECT
RAY_TRACING_ENTRY_RAYGEN(ReSTIRCandidateGenerationRGS)
{
	uint ReservoirIndex = ReservoirIndices[DispatchRaysIndex().x];
	uint2 PixelCoord = HVPT_GetPixelCoord(ReservoirIndex);

	ReSTIRCandidateGeneration_Main(PixelCoord, ReservoirIndex);
}
#else
RAY_TRACING_ENTRY_RAYGEN(ReSTIRCandidateGenerationRGS)
{
	uint2 PixelCoord = DispatchRaysIndex().xy;
	uint ReservoirIndex = HVPT_GetReservoirIndex(PixelCoord);

	ReSTIRCandidateGeneration_Main(PixelCoord, ReservoirIndex);
}
#endif


StructuredBuffer<FHVPT_Bounce> ExtraBounces;

void ReSTIRCandidateEvaluateF_Main(uint2 PixelCoord, uint ReservoirIndex)
{
	FHVPT_Reservoir Reservoir = RWCurrentReservoirs[ReservoirIndex];

	if (Reservoir.RunningSum <= 0.0f)
	{
		return;
	}

	FRayDesc PrimaryRay = HVPT_CreateRayDesc(PixelCoord);

	// For running sum to be greater than 0 the ray must have intersected with the volume
	FVolumeIntersection VolIntersect = HVPT_Intersect(PrimaryRay.Origin, PrimaryRay.Direction, PrimaryRay.TMin, PrimaryRay.TMax);
	PrimaryRay.TMin = VolIntersect.VolumeTMin;
	PrimaryRay.TMax = VolIntersect.VolumeTMax;

	// Create random sequence
	RandomSequence RandSequence = (RandomSequence)0;
	uint LinearPixelIndex = PixelCoord.y * View.ViewSizeAndInvSize.x + PixelCoord.x;
	RandomSequence_Initialize(RandSequence, LinearPixelIndex, TemporalSeed);

	// Load extra bounces
#if MULTIPLE_BOUNCES
	FHVPT_Bounce Bounces[MAX_EXTRA_BOUNCES];
	uint ExtraBounceIndex = HVPT_GetExtraBounceIndex(PixelCoord, 0);
	for (uint i = 0; i < Reservoir.GetNumExtraBounces(); i++)
	{
		Bounces[i] = ExtraBounces[ExtraBounceIndex + i];
	}
#endif

	// Evaluate PHat
	float PHat = Luminance(HVPT_EvaluateF<SHADING_QUALITY_CANDIDATE_GENERATION>(Reservoir,
#if MULTIPLE_BOUNCES
		Bounces,
#endif
		PrimaryRay, RandSequence));
	Reservoir.RunningSum *= (Reservoir.P_y == 0.0f) ? 0.0f : PHat / Reservoir.P_y;
	Reservoir.P_y = PHat;

	// Output reservoir
	RWCurrentReservoirs[ReservoirIndex] = Reservoir;
}

#if USE_DISPATCH_INDIRECT
RAY_TRACING_ENTRY_RAYGEN(ReSTIRCandidateEvaluateFRGS)
{
	uint ReservoirIndex = ReservoirIndices[DispatchRaysIndex().x];
	uint2 PixelCoord = HVPT_GetPixelCoord(ReservoirIndex);

	ReSTIRCandidateEvaluateF_Main(PixelCoord, ReservoirIndex);
}
#else
RAY_TRACING_ENTRY_RAYGEN(ReSTIRCandidateEvaluateFRGS)
{
	uint2 PixelCoord = DispatchRaysIndex().xy;
	uint ReservoirIndex = HVPT_GetReservoirIndex(PixelCoord);

	ReSTIRCandidateEvaluateF_Main(PixelCoord, ReservoirIndex);
}
#endif
