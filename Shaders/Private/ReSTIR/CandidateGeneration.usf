
// This needs to be first for generated uniform buffer ush to compile
#include "../VoxelGrid/VoxelGridTypes.ush"

#include "/Engine/Private/Common.ush"
#include "/Engine/Private/RayTracing/RayTracingCommon.ush"
#include "/Engine/Private/PathTracing/Volume/PathTracingVolumeCommon.ush"

#include "../../Shared/HVPTDefinitions.h"

#include "ReSTIRUtils.ush"
#include "PathEvaluation.ush"


#ifndef MULTIPLE_BOUNCES
#define MULTIPLE_BOUNCES true
#endif

#ifndef USE_SURFACE_CONTRIBUTIONS
#define USE_SURFACE_CONTRIBUTIONS true
#endif

// Uses a copy of the scene depth, that was made before writing HVPT into it
Texture2D<float> SceneDepthTexture_Copy;

uint TemporalSeed;

uint NumInitialCandidates;

RWStructuredBuffer<FHVPT_Reservoir> RWCurrentReservoirs;
RWStructuredBuffer<FHVPT_Bounce> RWExtraBounces;

// Debug tools
uint DebugFlags;
RWTexture2D<float3> RWDebugTexture;


// TODO: Handle early return when light PDF is 0
#if USE_SURFACE_CONTRIBUTIONS
float3 SampleDirectLightingSurface(
	FRayDesc Ray, 
	FPathTracingPayload Payload,
	bool bEnableShadow, 
	inout RandomSequence RandSequence, 
	out float OutLightPDF, 
	out uint OutLightId, 
	out float2 OutLightSample
)
{
	// Pick a light source to sample
	uint LightId = -1;
	float3 LightRandValue = RandomSequence_GenerateSample3D(RandSequence);
	FLightSample LightSample = HVPT_SampleLight(Payload.TranslatedWorldPos, Payload.WorldNormal, LightRandValue, LightId);

	// TODO: Handle diffuse specular scale for non media materials
	FMaterialEval MaterialEval = EvalMaterial(-Ray.Direction, LightSample.Direction, Payload, float2(1.0f, 0.0f));

	float3 Ld = MaterialEval.Weight * LightSample.RadianceOverPdf;
	if (bEnableShadow)
	{
		Ld *= HVPT_CalculateLightVisibility < false > (Payload.TranslatedWorldPos, LightSample, RandSequence);
	}

	OutLightPDF = LightSample.Pdf;
	OutLightId = LightId;
	OutLightSample = LightRandValue.yz;
	return Ld;
}
#endif


// TODO: Handle early return when light PDF is 0
float3 SampleDirectLighting(
	FRayDesc Ray,
	FHVPT_TrackingResult TrackingResult,
	float3 TranslatedWorldPos,
	bool bEnableShadow,
	inout RandomSequence RandSequence,
	out float OutLightPDF,
	out uint OutLightId,
	out float2 OutLightSample
)
{
	// Pick a light source to sample
	uint LightId = -1;
	float3 LightRandValue = RandomSequence_GenerateSample3D(RandSequence);
	FLightSample LightSample = HVPT_SampleLight(TranslatedWorldPos, 0.0f, LightRandValue, LightId);

	float Phase = HenyeyGreensteinPhase(TrackingResult.PhaseG, dot(-Ray.Direction, LightSample.Direction));

	float3 Ld = Phase * LightSample.RadianceOverPdf;
	if (bEnableShadow)
	{
		Ld *= HVPT_CalculateLightVisibility<false>(TranslatedWorldPos, LightSample, RandSequence);
	}

	OutLightPDF = LightSample.Pdf;
	OutLightId = LightId;
	OutLightSample = LightRandValue.yz;
	return Ld;
}


FHVPT_Reservoir ComputeInitialSample(
	FRayDesc Ray,
#if MULTIPLE_BOUNCES
	inout FHVPT_Bounce ExtraBounces[MAX_EXTRA_BOUNCES],
#endif
	inout RandomSequence RandSequence
)
{
	float PathPDF = 1.0f;
	float PathPHat = 1.0f;

#if MULTIPLE_BOUNCES
	// If single bounce, then only 1 reservoir will be produced so no need for a reservoir to accumulate into
	FHVPT_Reservoir CombinedReservoir = HVPT_CreateNewReservoir();
	float PrimaryScatterDepth = 0.0f;
#endif

	FHVPT_Reservoir OutReservoir;

	for (uint Bounce = 0; Bounce < NumBounces; Bounce++)
	{
		OutReservoir = HVPT_CreateNewReservoir();
		OutReservoir.M = 1;

		// Perform tracking to get a distance into the volume
		FRayCone RayCone = (FRayCone)0;
		FMaterialClosestHitPayload HitInfo = TraceMaterialRay(
			TLAS,
			0,
			PATHTRACER_MASK_ALL,
			Ray,
			RayCone,
			false,
			true,
			false
		);
		if (HitInfo.IsHit())
		{
			Ray.TMax = HitInfo.HitT;
		}

#if USE_SURFACE_CONTRIBUTIONS
		FPathTracingPayload Payload = HVPT_CreateSurfaceHitPayload(HitInfo);
#endif

		FHVPT_TrackingResult TrackingResult = HVPT_DeltaTracking(Ray, RandSequence);
		float PDFDist = Luminance(TrackingResult.SigmaT * TrackingResult.Transmittance);
		bool bVolumeInteractionValid = TrackingResult.Distance != POSITIVE_INFINITY;

		float3 TranslatedWorldPos = Ray.Origin + TrackingResult.Distance * Ray.Direction;

		PathPDF *= PDFDist;

		bool bHitEmpty = false;

		if (Bounce == 0)
		{
			OutReservoir.Depth = TrackingResult.Distance; // If tracking did not intersect volume then distance will be POSITIVE_INFINITY anyway
#if MULTIPLE_BOUNCES
			PrimaryScatterDepth = OutReservoir.Depth;
		}
		else
		{
			// Add vertex to path
			OutReservoir.Depth = PrimaryScatterDepth;
			OutReservoir.NumExtraBounces = Bounce;
			ExtraBounces[Bounce - 1].Direction = Ray.Direction;
			ExtraBounces[Bounce - 1].Distance = TrackingResult.Distance;
#endif
		}
		OutReservoir.P_y = PathPDF;

		if (
#if !(USE_SURFACE_CONTRIBUTIONS)
			(!bVolumeInteractionValid && Bounce > 0) ||
#endif
			(bVolumeInteractionValid && all(TrackingResult.SigmaT == 0.0f))
		)
		{
			OutReservoir.P_y = 0.0f;
			OutReservoir.RunningSum = 0.0f;
			bHitEmpty = true;
		}

		float PDFDir = 1.0f;

		if (!bHitEmpty)
		{
			if (bVolumeInteractionValid
#if USE_SURFACE_CONTRIBUTIONS
				|| HitInfo.IsHit()
#endif
			)
			{
				bool bIsSurfaceHit = !bVolumeInteractionValid;

				float3 Albedo = TrackingResult.SigmaS / TrackingResult.SigmaT;

#if USE_SURFACE_CONTRIBUTIONS
				if (bIsSurfaceHit)
				{
					if (any(Payload.Radiance > 0.0f))
					{
						if (Bounce == 0)
						{
							float3 Le = Payload.Radiance;
							PathPHat *= Luminance(TrackingResult.Transmittance);
							float P_y = PathPHat * Luminance(Le);
							OutReservoir.RunningSum = P_y / OutReservoir.P_y;
							OutReservoir.P_y = P_y;
							OutReservoir.bEmissionPath = true;
						}
						else
						{
							OutReservoir.RunningSum = 0.0f;
							OutReservoir.P_y = 0.0f;
						}
						bHitEmpty = true;
					}
				}
#endif

				if (!bHitEmpty)
				{
					float OutLightPDF = 0.0f;
					float3 Ld = 0.0f;
					float3 Le = 0.0f;

					// Absorption ratio
					float3 OneMinusAlbedo = 1.0f - Albedo;
					bool bSampleLightOrEmission = true;

					// Include emission if volume has emission
					if (any(TrackingResult.Emission > 0.0f) && any(TrackingResult.SigmaT > 0.0f) && !bIsSurfaceHit)
					{
						Le = TrackingResult.Emission;
					}

#if USE_SURFACE_CONTRIBUTIONS
					if (bIsSurfaceHit)
					{
						Ld = SampleDirectLightingSurface(
							Ray, Payload, true, RandSequence, OutLightPDF, OutReservoir.LightId, OutReservoir.LightSample
						);
					}
					else
#endif
					{
						Ld = SampleDirectLighting(
							Ray, TrackingResult, TranslatedWorldPos, true, RandSequence, OutLightPDF, OutReservoir.LightId, OutReservoir.LightSample
						);
					}

					// Select new direction for ray to bounce in
					float3 wi;

					if (NumBounces > 1)
					{
#if USE_SURFACE_CONTRIBUTIONS
						if (bIsSurfaceHit)
						{
							// This will break the loop after this bounce, but still consider a path connecting from the surface hit to a light source
							bHitEmpty = true;
						}
						else
#endif
						{
							// Sample phase function for new scattering direction
							float4 DirectionAndPDF = ImportanceSampleHenyeyGreensteinPhase(RandomSequence_GenerateSample2D(RandSequence), TrackingResult.PhaseG);
							wi = TangentToWorld(DirectionAndPDF.xyz, Ray.Direction);
							PDFDir = DirectionAndPDF.w;
						}
					}

					float PSrc = OutReservoir.P_y;

#if USE_SURFACE_CONTRIBUTIONS
					if (bIsSurfaceHit)
					{
						PSrc *= OutLightPDF;
					}
					else
#endif 
					if (bSampleLightOrEmission)
					{
						// Perform RIS step
						float EmissionWeight = Luminance(OneMinusAlbedo * Le);
						float EmissionRatio = EmissionWeight / (EmissionWeight + Luminance(Albedo * Ld));
						if (isnan(EmissionRatio))
							EmissionRatio = 0.0f;

						// Sample between emission and in-scattering
						if (RandomSequence_GenerateSample1D(RandSequence) < EmissionRatio)
						{
							PSrc *= EmissionRatio;
							OutReservoir.bEmissionPath = true;
						}
						else
						{
							PSrc *= OutLightPDF * (1.0f - EmissionRatio);
						}
					}

					OutReservoir.RunningSum = (PSrc == 0.0f) ? 0.0f : 1.0f;
					OutReservoir.P_y = PSrc;

					float P_y = 0.0f;
					PathPHat *= Luminance(TrackingResult.Transmittance);

#if USE_SURFACE_CONTRIBUTIONS
					if (bIsSurfaceHit)
					{
						// Don't need to do anything here - if surface hit then there won't be another iteration for PathPHat to be used
					}
					else
#endif
					{
						PathPHat *= Luminance(TrackingResult.SigmaT);
						if (OutReservoir.bEmissionPath)
						{
							float3 SigmaA = TrackingResult.SigmaT - TrackingResult.SigmaS;
							P_y = PathPHat * Luminance(SigmaA * Le);
						}
						else
						{
							// Ld is pre-divided by PDF
							P_y = PathPHat * Luminance(TrackingResult.SigmaS * Ld * OutLightPDF);
						}

						PathPHat *= Luminance(TrackingResult.SigmaS) * PDFDir;
					}

					if (OutReservoir.RunningSum > 0.0f)
					{
						OutReservoir.RunningSum = (OutReservoir.P_y == 0.0f) ? 0.0f : P_y / OutReservoir.P_y;

						if (OutReservoir.bEmissionPath && Bounce > 0)
						{
							// TODO: Do I need to reflect this in Final Shading?
							// This makes absorption insanely strong as is at the moment!
							//P_y /= (TrackingResult.Distance * TrackingResult.Distance);
						}
						OutReservoir.P_y = P_y;
					}

					PathPDF *= PDFDir;

#if MULTIPLE_BOUNCES
					if (!bHitEmpty && Bounce < NumBounces - 1)
					{
						// Create a new ray pointing in the sampled direction
						Ray = HVPT_CreateRayDesc(TranslatedWorldPos, wi);
					}
#endif
				}
			}
			else
			{
				// Didn't hit volume or surface
				OutReservoir.RunningSum = 0.0f;
				OutReservoir.P_y = 0.0f;
				bHitEmpty = true;
			}
		}

#if MULTIPLE_BOUNCES
		HVPT_SimpleResampleStep<false>(OutReservoir, CombinedReservoir, RandomSequence_GenerateSample1D(RandSequence));
#endif
		if (bHitEmpty)
			break;
	}

#if MULTIPLE_BOUNCES
	CombinedReservoir.M = 1;
	return CombinedReservoir;
#else
	return OutReservoir;
#endif
}


RAY_TRACING_ENTRY_RAYGEN(ReSTIRCandidateGenerationRGS)
{
	uint2 PixelCoord = DispatchRaysIndex().xy;
FHVPT_Reservoir FinalReservoir = HVPT_CreateNewReservoir();

#if MULTIPLE_BOUNCES
	FHVPT_Bounce FinalExtraBounces[MAX_EXTRA_BOUNCES];
#endif

	// Get ray origin and direction
	float DeviceZ = SceneDepthTexture_Copy.Load(uint3(PixelCoord, 0)).r;
	FRayDesc Ray = HVPT_CreateRayDesc<true>(PixelCoord, DeviceZ);

	// Find extents of intersection with volume bounding box
	FVolumeIntersection VolIntersect = HVPT_Intersect(Ray.Origin, Ray.Direction, Ray.TMin, Ray.TMax);
	if (!VolIntersect.HitVolume())
	{
		// Output an empty reservoir
		RWCurrentReservoirs[HVPT_GetReservoirIndex(PixelCoord)] = FinalReservoir;
		return;
	}

	Ray.TMin = VolIntersect.VolumeTMin;
	Ray.TMax = VolIntersect.VolumeTMax;

	FRayDesc PrimaryRay = Ray;

	// Create random sequence
	RandomSequence RandSequence = (RandomSequence)0;
	uint LinearPixelIndex = PixelCoord.y * View.ViewSizeAndInvSize.x + PixelCoord.x;
	RandomSequence_Initialize(RandSequence, LinearPixelIndex, TemporalSeed);

	// Create initial samples
	for (uint m = 0; m < NumInitialCandidates; m++)
	{
#if MULTIPLE_BOUNCES
		FHVPT_Bounce OutBounces[MAX_EXTRA_BOUNCES];
#endif

		FHVPT_Reservoir OutReservoir = ComputeInitialSample(PrimaryRay, 
#if MULTIPLE_BOUNCES
			OutBounces, 
#endif
			RandSequence);

		bool bSelected = HVPT_SimpleResampleStep<false>(OutReservoir, FinalReservoir, RandomSequence_GenerateSample1D(RandSequence));

		if (bSelected)
		{
#if MULTIPLE_BOUNCES
			for (uint Bounce = 0; Bounce < FinalReservoir.NumExtraBounces; Bounce++)
			{
				FinalExtraBounces[Bounce] = OutBounces[Bounce];
			}
#endif
		}
	} // For each initial candidate

	// Store the sampled pixel in the reservoir, this is used to later retrieve its extra bounces
	// TODO: Can be converted to a 1D index into extra bounce index?
	FinalReservoir.SampledPixel = PixelCoord;

	// Evaluate PHat
	if (FinalReservoir.RunningSum > 0.0f)
	{
		float PHat = Luminance(HVPT_EvaluateF<false>(FinalReservoir,
#if MULTIPLE_BOUNCES
			FinalExtraBounces,
#endif
			PrimaryRay, RandSequence));
		FinalReservoir.RunningSum *= (FinalReservoir.P_y == 0.0f) ? 0.0f : PHat / FinalReservoir.P_y;
		FinalReservoir.P_y = PHat;
	}

	// Output reservoir
	RWCurrentReservoirs[HVPT_GetReservoirIndex(PixelCoord)] = FinalReservoir;

#if MULTIPLE_BOUNCES
	// Output bounces
	uint ExtraBounceIndex = HVPT_GetExtraBounceIndex(PixelCoord, 0);
	for (uint i = 0; i < FinalReservoir.NumExtraBounces; i++)
	{
		RWExtraBounces[ExtraBounceIndex + i] = FinalExtraBounces[i];
	}
#endif
}
