#ifndef RAYTRACINGUTILS_H
#define RAYTRACINGUTILS_H

#include "/Engine/Private/RayTracing/RayTracingCommon.ush"

#if USE_SER
#include "/Engine/Private/RayTracing/HitObjectSupport.ush"
#endif


void HVPT_TraceVisibilityRayPacked(
	inout FPackedMaterialClosestHitPayload PackedPayload,
	RaytracingAccelerationStructure TLAS,
	FRayDesc Ray)
{
	const uint RayFlags = RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER;
	const uint InstanceInclusionMask = PATHTRACER_MASK_ALL;
	const uint RayContributionToHitGroupIndex = RAY_TRACING_SHADER_SLOT_SHADOW;
	const uint MultiplierForGeometryContributionToShaderIndex = RAY_TRACING_NUM_SHADER_SLOTS;
	const uint MissShaderIndex = 0;

	// By enabling minimal payload mode all other payload information is ignored, meaning these functions need no payload inputs
	PackedPayload.SetMinimalPayloadMode();
	PackedPayload.HitT = 0;

	// Trace the ray
#if USE_SER
	{
		NvHitObject Hit;
		NvTraceRayHitObject(
			TLAS,
			RayFlags,
			InstanceInclusionMask,
			RayContributionToHitGroupIndex,
			MultiplierForGeometryContributionToShaderIndex,
			MissShaderIndex,
			Ray.GetNativeDesc(),
			PackedPayload,
			Hit);
		NvReorderThread(Hit);
		NvInvokeHitObject(TLAS, Hit, PackedPayload);
	}
#else
	TraceRay(
		TLAS,
		RayFlags,
		InstanceInclusionMask,
		RayContributionToHitGroupIndex,
		MultiplierForGeometryContributionToShaderIndex,
		MissShaderIndex,
		Ray.GetNativeDesc(),
		PackedPayload);
#endif
}

FMinimalPayload HVPT_TraceVisibilityRay(
	RaytracingAccelerationStructure TLAS,
	FRayDesc Ray)
{
	FPackedMaterialClosestHitPayload PackedPayload = (FPackedMaterialClosestHitPayload) 0;
	PackedPayload.SetFlags(RAY_TRACING_PAYLOAD_INPUT_FLAG_SHADOW_RAY);
	PackedPayload.SetIgnoreTranslucentMaterials();

	HVPT_TraceVisibilityRayPacked(PackedPayload, TLAS, Ray);

	// Unpack the payload
	FMinimalPayload MinimalPayload = (FMinimalPayload) 0;

	// In theory this unpacking setp is not needed as FPackedMaterialClosestHitPayload derives from FMinimalPayload,
	// but the compiler currently dislikes a direct cast between them. Additionally in the future if HitT is ever packed
	// differently and the FMinimalPayload is not directly inherited from this will need to change.
	MinimalPayload.HitT = PackedPayload.HitT;

	return MinimalPayload;
}


FMaterialClosestHitPayload HVPT_TraceMaterialRay(
	RaytracingAccelerationStructure TLAS,
	FRayDesc Ray)
{
	const uint RayFlags = 0;
	const uint InstanceInclusionMask = PATHTRACER_MASK_ALL;
	const uint RayContributionToHitGroupIndex = RAY_TRACING_SHADER_SLOT_MATERIAL;
	const uint MultiplierForGeometryContributionToShaderIndex = RAY_TRACING_NUM_SHADER_SLOTS;
	const uint MissShaderIndex = 0;

	FPackedMaterialClosestHitPayload PackedPayload = (FPackedMaterialClosestHitPayload) 0;
	PackedPayload.SetEnableSkyLightContribution();
	PackedPayload.SetIgnoreTranslucentMaterials();

	// Trace the ray
#if	USE_SER
	{
		NvHitObject Hit;
		NvTraceRayHitObject(
			TLAS,
			RayFlags,
			InstanceInclusionMask,
			RayContributionToHitGroupIndex,
			MultiplierForGeometryContributionToShaderIndex,
			MissShaderIndex,
			Ray.GetNativeDesc(),
			PackedPayload,
			Hit);
		NvReorderThread(Hit);
		NvInvokeHitObject(TLAS, Hit, PackedPayload);
	}
#else
	TraceRay(
		TLAS,
		RayFlags,
		InstanceInclusionMask,
		RayContributionToHitGroupIndex,
		MultiplierForGeometryContributionToShaderIndex,
		MissShaderIndex,
		Ray.GetNativeDesc(),
		PackedPayload);
#endif
	// Unpack the payload
	FMaterialClosestHitPayload Payload = UnpackRayTracingPayload(PackedPayload, Ray);
	return Payload;
}

#endif