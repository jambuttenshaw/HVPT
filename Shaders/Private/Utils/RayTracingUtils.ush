#ifndef RAYTRACINGUTILS_H
#define RAYTRACINGUTILS_H

#include "/Engine/Private/RayTracing/RayTracingCommon.ush"

#if USE_SER
#include "/Engine/Private/RayTracing/HitObjectSupport.ush"
#endif


void HVPT_TraceVisibilityRayPacked(
	inout FPackedMaterialClosestHitPayload PackedPayload,
	RaytracingAccelerationStructure TLAS,
	uint RayFlags,
	uint InstanceInclusionMask,
	FRayDesc Ray)
{
	const uint RayContributionToHitGroupIndex = RAY_TRACING_SHADER_SLOT_SHADOW;
	const uint MultiplierForGeometryContributionToShaderIndex = RAY_TRACING_NUM_SHADER_SLOTS;
	const uint MissShaderIndex = 0;

	// By enabling minimal payload mode all other payload information is ignored, meaning these functions need no payload inputs
	PackedPayload.SetMinimalPayloadMode();
	PackedPayload.HitT = 0;

	// Trace the ray
#if USE_SER
	{
		NvHitObject Hit;
		NvTraceRayHitObject(
			TLAS,
			RayFlags,
			InstanceInclusionMask,
			RayContributionToHitGroupIndex,
			MultiplierForGeometryContributionToShaderIndex,
			MissShaderIndex,
			Ray.GetNativeDesc(),
			PackedPayload,
			Hit);
		NvReorderThread(Hit);
		NvInvokeHitObject(TLAS, Hit, PackedPayload);
	}
#else
	TraceRay(
		TLAS,
		RayFlags,
		InstanceInclusionMask,
		RayContributionToHitGroupIndex,
		MultiplierForGeometryContributionToShaderIndex,
		MissShaderIndex,
		Ray.GetNativeDesc(),
		PackedPayload);
#endif
}

FMinimalPayload HVPT_TraceVisibilityRay(
	RaytracingAccelerationStructure TLAS,
	uint RayFlags,
	uint InstanceInclusionMask,
	FRayDesc Ray)
{
	FPackedMaterialClosestHitPayload PackedPayload = (FPackedMaterialClosestHitPayload) 0;
	
	PackedPayload.SetFlags(RAY_TRACING_PAYLOAD_INPUT_FLAG_SHADOW_RAY);
	PackedPayload.SetIgnoreTranslucentMaterials();

	HVPT_TraceVisibilityRayPacked(PackedPayload, TLAS, RayFlags, InstanceInclusionMask, Ray);

	// Unpack the payload
	FMinimalPayload MinimalPayload = (FMinimalPayload) 0;

	// In theory this unpacking setp is not needed as FPackedMaterialClosestHitPayload derives from FMinimalPayload,
	// but the compiler currently dislikes a direct cast between them. Additionally in the future if HitT is ever packed
	// differently and the FMinimalPayload is not directly inherited from this will need to change.
	MinimalPayload.HitT = PackedPayload.HitT;

	return MinimalPayload;
}


FMaterialClosestHitPayload HVPT_TraceMaterialRay(
	RaytracingAccelerationStructure TLAS,
	uint RayFlags,
	uint InstanceInclusionMask,
	FRayDesc Ray,
	// Payload Inputs
	inout FRayCone RayCone,
	bool bEnableSkyLightContribution,
	bool bIgnoreTranslucentMaterials,
	bool bIsCameraRay)
{
	const uint RayContributionToHitGroupIndex = RAY_TRACING_SHADER_SLOT_MATERIAL;
	const uint MultiplierForGeometryContributionToShaderIndex = RAY_TRACING_NUM_SHADER_SLOTS;
	const uint MissShaderIndex = 0;

	FPackedMaterialClosestHitPayload PackedPayload = (FPackedMaterialClosestHitPayload) 0;

	// Set payload inputs

	PackedPayload.SetRayCone(RayCone);

	if (bEnableSkyLightContribution)
	{
		// Enable Sky Light contribution in the payload if requested
		PackedPayload.SetEnableSkyLightContribution();
	}
	
	if (bIgnoreTranslucentMaterials)
	{
		PackedPayload.SetIgnoreTranslucentMaterials();
	}

	if (bIsCameraRay)
	{
		PackedPayload.SetCameraRay();
	}

	// Trace the ray
#if	USE_SER
	{
		NvHitObject Hit;
		NvTraceRayHitObject(
			TLAS,
			RayFlags,
			InstanceInclusionMask,
			RayContributionToHitGroupIndex,
			MultiplierForGeometryContributionToShaderIndex,
			MissShaderIndex,
			Ray.GetNativeDesc(),
			PackedPayload,
			Hit);
		if (!bIsCameraRay)
		{
			NvReorderThread(Hit);
		}
		NvInvokeHitObject(TLAS, Hit, PackedPayload);
	}
#else
	TraceRay(
		TLAS,
		RayFlags,
		InstanceInclusionMask,
		RayContributionToHitGroupIndex,
		MultiplierForGeometryContributionToShaderIndex,
		MissShaderIndex,
		Ray.GetNativeDesc(),
		PackedPayload);
#endif
	// Unpack the payload
	FMaterialClosestHitPayload Payload = UnpackRayTracingPayload(PackedPayload, Ray);

	RayCone = Payload.GetRayCone();

	return Payload;
}

#endif