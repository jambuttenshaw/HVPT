#ifndef DDAUTILS_H
#define DDAUTILS_H

#include "../VoxelGrid/VoxelGridTypes.ush"
#include "../VoxelGrid/VoxelGridUtils.ush"
#include "../VoxelGrid/VoxelGridBuildUtils.ush"

#include "/Engine/Private/MortonCode.ush"


// DDA context used to iterate through cells in the grid along a ray
// ALWAYS use GetVoxelIndex() to access data specific to a cell in the grid
// - it will not suffer from floating point precision errors that GetVoxelEntry/Exit will!
struct FHVPT_GridIterator
{
	int3 CurrentVoxelPos; // Current index in the voxel grid
	int3 NextVoxelPos; // Next index in the voxel grid (to make DDA easy to use, both next and current are stored. In future this could be re-arranged)
	float RayMarchT; // Current T

	float DeltaT; // Step size through the current voxel
	float TMax; // End T

	float3 Direction;
	float3 Delta; // Distance to move along each axis - equal to abs(1 / Direction)

	float3 BoundsHitT; // T value for next hit on each axis

	float DistanceScale; // Scale factor for distances out of voxel space

	float3 VoxelSpaceBegin; // For calculating points along the ray without accumulating floating point error

	// Note: It is expected VoxelSpace Begin and End will be inside/on boundary of the grid!
	// WorldSpace_TMax is required to compute a scaling factor for distance values
	void Init(float3 VoxelSpace_Begin, float3 VoxelSpace_End, float WorldSpace_TMax)
	{
		VoxelSpaceBegin = VoxelSpace_Begin;
		Direction = VoxelSpace_End - VoxelSpace_Begin;

		RayMarchT = 0.0f;
		TMax = length(Direction);

		DistanceScale = WorldSpace_TMax / TMax;

		Direction /= TMax;
		Delta = select(Direction == 0.0f, POSITIVE_INFINITY, abs(1.0f / Direction));

		float3 VoxelBoundsPos = select(sign(Direction) > 0, floor(VoxelSpaceBegin) + 1, ceil(VoxelSpaceBegin) - 1);
		BoundsHitT = abs((VoxelBoundsPos - VoxelSpaceBegin) * Delta);

		DeltaT = 0.0f;
		NextVoxelPos = floor(VoxelSpaceBegin);
		CurrentVoxelPos = NextVoxelPos;
	}

	bool Next()
	{
		if ((DeltaT + RayMarchT) >= TMax)
		{
			return false;
		}

		CurrentVoxelPos = NextVoxelPos;
		RayMarchT += DeltaT;
		
		float MinComponent = min3(BoundsHitT.x, BoundsHitT.y, BoundsHitT.z);
		uint3 Axis = BoundsHitT == MinComponent;

		DeltaT = MinComponent - RayMarchT;
		BoundsHitT += Axis * Delta;
		NextVoxelPos += Axis * sign(Direction);

		// Clip voxel delta-t by overall voxel ray-length.
		if (RayMarchT + DeltaT > TMax)
		{
			DeltaT = TMax - RayMarchT;
		}

		return true;
	}

	uint3 GetVoxelIndex()
	{
		// CurrentVoxelPos should never be able to be outside range of grid
		return (uint3)CurrentVoxelPos;
	}

	float3 GetVoxelEntry()
	{
		// Offset ensures entry point is always inside voxel
		return VoxelSpaceBegin + (RayMarchT + 1e-4f) * Direction;
	}

	float3 GetVoxelExit()
	{
		// Offset ensures exit point is always inside voxel
		return VoxelSpaceBegin + (RayMarchT + DeltaT - 1e-4f) * Direction;
	}

	float3 GetVoxelMidpoint()
	{
		// If DeltaT is distance through voxel, then half of DeltaT is distance to middle of voxel
		return 0.5f * (GetVoxelEntry() + GetVoxelExit());
	}

	float GetWorldDeltaT()
	{
		return DeltaT * DistanceScale;
	}

	float GetDistanceScale()
	{
		return DistanceScale;
	}
};


FHVPT_GridIterator HVPT_CreateTopLevelIterator(float3 Origin, float3 Direction, float TMin, float TMax)
{
	// Initialize DDA state
	float3 WorldRayBegin = Origin + Direction * TMin;
	float3 WorldRayEnd = Origin + Direction * TMax;
	float WorldRayTMax = length(WorldRayEnd - WorldRayBegin);

	// Transform to voxel-space
	float3 WorldBoundsMin = HVPT_GetTranslatedWorldPos(HVPT_OrthoGrid.TopLevelGridWorldBoundsMin);
	float3 WorldBoundsMax = HVPT_GetTranslatedWorldPos(HVPT_OrthoGrid.TopLevelGridWorldBoundsMax);
	float3 TopLevelGridWorldBoundsExtent = WorldBoundsMax - WorldBoundsMin;

	float3 VoxelRayBegin = saturate((WorldRayBegin - WorldBoundsMin) / TopLevelGridWorldBoundsExtent) * ((float) HVPT_OrthoGrid.TopLevelGridResolution - 1e-3f);
	float3 VoxelRayEnd   = saturate((WorldRayEnd   - WorldBoundsMin) / TopLevelGridWorldBoundsExtent) * ((float) HVPT_OrthoGrid.TopLevelGridResolution - 1e-3f);

	FHVPT_GridIterator Iterator = (FHVPT_GridIterator)0;
	Iterator.Init(VoxelRayBegin, VoxelRayEnd, WorldRayTMax);
	return Iterator;
}

FHVPT_GridIterator HVPT_CreateBottomLevelIterator(float3 TopLevelVoxelEntry, float3 TopLevelVoxelExit, float TopLevelVoxelToWorldScale, uint3 BottomLevelVoxelResolution)
{
	// TODO: I believe there is some issue in this function to be diagnosed.
	float3 BottomLevelRayBegin = frac(TopLevelVoxelEntry) * BottomLevelVoxelResolution;
	float3 BottomLevelRayEnd = frac(TopLevelVoxelExit) * BottomLevelVoxelResolution;

	FHVPT_GridIterator Iterator = (FHVPT_GridIterator)0;
	Iterator.Init(BottomLevelRayBegin, BottomLevelRayEnd, length(TopLevelVoxelExit - TopLevelVoxelEntry) * TopLevelVoxelToWorldScale);
	return Iterator;
}


uint HVPT_GetTopLevelLinearIndex(FHVPT_GridIterator Iterator)
{
	return GetLinearIndex(Iterator.GetVoxelIndex(), HVPT_OrthoGrid.TopLevelGridResolution);
}

uint HVPT_GetBottomLevelLinearIndex(FHVPT_GridIterator Iterator, uint BottomLevelIndex)
{
	return BottomLevelIndex + MortonEncode3(Iterator.GetVoxelIndex());
}


#endif