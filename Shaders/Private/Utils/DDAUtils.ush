#ifndef DDAUTILS_H
#define DDAUTILS_H

#include "../VoxelGrid/VoxelGridTypes.ush"
#include "../VoxelGrid/VoxelGridUtils.ush"
#include "../VoxelGrid/VoxelGridBuildUtils.ush"

#include "/Engine/Private/MortonCode.ush"


// DDA context used to iterate through cells in the grid along a ray
// ALWAYS use GetVoxelIndex() to access data specific to a cell in the grid
// - it will not suffer from floating point precision errors that GetVoxelEntry/Exit will!
struct FHVPT_GridIterator
{
	int3 GridResolution;

	int3 CurrentVoxelPos; // Current index in the voxel grid
	int3 NextVoxelPos; // Next index in the voxel grid (to make DDA easy to use, both next and current are stored. In future this could be re-arranged)
	float RayMarchT_VoxelSpace; // Current T

	float DeltaT_VoxelSpace; // Step size through the current voxel
	float TMax_VoxelSpace; // End T

	float3 Direction;
	float3 DeltaStep; // Distance to move along each axis - equal to abs(1 / Direction)

	float3 BoundsHitT; // T value for next hit on each axis

	float DistanceScale; // Scale factor for distances out of voxel space

	float3 Begin_VoxelSpace; // For calculating points along the ray without accumulating floating point error

	// Note: It is expected VoxelSpace Begin and End will be inside/on boundary of the grid!
	// WorldSpace_TMax is required to compute a scaling factor for distance values
	void Init(float3 VoxelSpace_Begin, float3 VoxelSpace_End, float WorldSpace_TMax, int3 InGridResolution)
	{
		GridResolution = InGridResolution;

		Begin_VoxelSpace = VoxelSpace_Begin;
		Direction = VoxelSpace_End - VoxelSpace_Begin;

		RayMarchT_VoxelSpace = 0.0f;
		TMax_VoxelSpace = length(Direction);
		if (isinf(TMax_VoxelSpace) || isnan(TMax_VoxelSpace))
			TMax_VoxelSpace = 0.0f;

		DistanceScale = TMax_VoxelSpace > 0.0f ? WorldSpace_TMax / TMax_VoxelSpace : 0.0f;

		Direction /= TMax_VoxelSpace;
		DeltaStep = select(Direction == 0.0f, POSITIVE_INFINITY, abs(1.0f / Direction));

		float3 VoxelBoundsPos = select(sign(Direction) > 0, floor(Begin_VoxelSpace) + 1, ceil(Begin_VoxelSpace) - 1);
		BoundsHitT = abs((VoxelBoundsPos - Begin_VoxelSpace) * DeltaStep);

		DeltaT_VoxelSpace = 0.0f;
		NextVoxelPos = floor(Begin_VoxelSpace);
		CurrentVoxelPos = NextVoxelPos;
	}

	bool Next()
	{
		if (DeltaT_VoxelSpace + RayMarchT_VoxelSpace >= TMax_VoxelSpace || any(NextVoxelPos < 0) || any(NextVoxelPos >= GridResolution))
		{
			DeltaT_VoxelSpace = 0.0f;
			return false;
		}

		CurrentVoxelPos = NextVoxelPos;
		RayMarchT_VoxelSpace += DeltaT_VoxelSpace;

		// Select axis that will cross a voxel boundary next
		float MinComponent = min3(BoundsHitT.x, BoundsHitT.y, BoundsHitT.z);
		uint3 Axis = BoundsHitT == MinComponent;

		DeltaT_VoxelSpace = MinComponent - RayMarchT_VoxelSpace;
		BoundsHitT += Axis * DeltaStep;
		NextVoxelPos += Axis * sign(Direction);

		// Clip voxel delta-t by overall voxel ray-length.
		DeltaT_VoxelSpace = min(DeltaT_VoxelSpace, TMax_VoxelSpace - RayMarchT_VoxelSpace);

		return true;
	}

	uint3 GetVoxelIndex()
	{
		// CurrentVoxelPos should never be able to be outside range of grid
		return (uint3)CurrentVoxelPos;
	}

	// Entry point of voxel in voxel space
	float3 GetVoxelEntry()
	{
		// Offset ensures entry point is always inside voxel
		return Begin_VoxelSpace + (RayMarchT_VoxelSpace + 1e-4f) * Direction;
	}

	// Exit point from voxel in voxel space
	float3 GetVoxelExit()
	{
		// Offset ensures exit point is always inside voxel
		return Begin_VoxelSpace + (RayMarchT_VoxelSpace + DeltaT_VoxelSpace - 1e-4f) * Direction;
	}

	// Midpoint of ray through voxel in voxel space
	float3 GetVoxelMidpoint()
	{
		// If DeltaT is distance through voxel, then half of DeltaT is distance to middle of voxel
		return 0.5f * (GetVoxelEntry() + GetVoxelExit());
	}

	float GetWorldDeltaT()
	{
		return DeltaT_VoxelSpace * DistanceScale;
	}

	float GetDistanceScale()
	{
		return DistanceScale;
	}
};


FHVPT_GridIterator HVPT_CreateTopLevelIterator(float3 Origin, float3 Direction, float TMin, float TMax)
{
	FHVPT_GridIterator Iterator = (FHVPT_GridIterator) 0;

	float3 WorldBoundsMin = HVPT_GetTranslatedWorldPos(HVPT_OrthoGrid.TopLevelGridWorldBoundsMin);
	float3 WorldBoundsMax = HVPT_GetTranslatedWorldPos(HVPT_OrthoGrid.TopLevelGridWorldBoundsMax);
	float3 TopLevelGridWorldBoundsExtent = WorldBoundsMax - WorldBoundsMin;

	// Clip ray to where it intersects with the volume bounding box
	float2 RayHitT = IntersectAABB(
			Origin,
			Direction,
			TMin,
			TMax,
			WorldBoundsMin,
			WorldBoundsMax
		);
	if (RayHitT.x >= RayHitT.y)
	{
		// Will be 0 initialized: DeltaT will always be 0, and Next() will always return false
		return Iterator;
	}
	TMin = max(TMin, RayHitT.x);
	TMax = min(TMax, RayHitT.y);

	// Transform begin and end to voxel space
	float3 WorldRayBegin = Origin + Direction * TMin;
	float3 WorldRayEnd = Origin + Direction * TMax;
	float WorldRayTMax = length(WorldRayEnd - WorldRayBegin);

	float3 VoxelRayBegin = saturate((WorldRayBegin - WorldBoundsMin) / TopLevelGridWorldBoundsExtent) * ((float) HVPT_OrthoGrid.TopLevelGridResolution - 1e-3f);
	float3 VoxelRayEnd   = saturate((WorldRayEnd   - WorldBoundsMin) / TopLevelGridWorldBoundsExtent) * ((float) HVPT_OrthoGrid.TopLevelGridResolution - 1e-3f);

	// Initialize DDA state
	Iterator.Init(VoxelRayBegin, VoxelRayEnd, WorldRayTMax, HVPT_OrthoGrid.TopLevelGridResolution);
	return Iterator;
}

FHVPT_GridIterator HVPT_CreateBottomLevelIterator(float3 TopLevelVoxelEntry, float3 TopLevelVoxelExit, float TopLevelVoxelToWorldScale, uint3 BottomLevelVoxelResolution)
{
	float3 BottomLevelRayBegin = frac(TopLevelVoxelEntry) * BottomLevelVoxelResolution;
	float3 BottomLevelRayEnd = frac(TopLevelVoxelExit) * BottomLevelVoxelResolution;

	FHVPT_GridIterator Iterator = (FHVPT_GridIterator)0;
	Iterator.Init(BottomLevelRayBegin, BottomLevelRayEnd, length(TopLevelVoxelExit - TopLevelVoxelEntry) * TopLevelVoxelToWorldScale, BottomLevelVoxelResolution);
	return Iterator;
}


uint HVPT_GetTopLevelLinearIndex(FHVPT_GridIterator Iterator)
{
	return GetLinearIndex(Iterator.GetVoxelIndex(), HVPT_OrthoGrid.TopLevelGridResolution);
}

uint HVPT_GetBottomLevelLinearIndex(FHVPT_GridIterator Iterator, uint BottomLevelIndex)
{
	return BottomLevelIndex + MortonEncode3(Iterator.GetVoxelIndex());
}


#endif