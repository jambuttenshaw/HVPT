#ifndef TRACKINGUTILS_H
#define TRACKINGUTILS_H

#include "/Engine/Private/RayTracing/RayTracingCommon.ush"

#include "/Engine/Private/PathTracing/Utilities/PathTracingRandomSequence.ush"
#include "/Engine/Private/PathTracing/Volume/PathTracingVolumeCommon.ush"

#include "DDAUtils.ush"
#include "../VoxelGrid/VoxelGridUtils.ush"

//
// --- HETEROGENEOUS VOLUME SAMPLING METHODS
//

struct FHVPT_MajorantSample
{
	float Distance; // The parametric T value of where the sample occurred

	float3 SigmaMaj; // The majorant at the sample location
	float3 MajorantTransmittance;

	// TODO: Also include PDF in the sample (will allow for underlying calculation of PDF to be abstracted, e.g. if moving to chromatic sampling)

	bool IsValid()
	{
		// TODO: Is a T of 0 possible / desirable?
		return Distance >= 0.0f;
	}
};


struct FHVPT_MajorantSamplingContext
{
	// Contains the state for iterating through voxels along the ray using DDA
	FHVPT_GridIterator Iterator;

	float RayOriginToSegmentDistance; // Distance from RAY ORIGIN to the beginning of the current segment
	float CurrentSegmentT; // Distance from where the ray enters the current segment to the last sample point
	float3 SigmaMaj; // Majorant of the current segment
	float3 MajorantTransmittance; // Accumulated transmittance since LAST SAMPLE WAS TAKEN
	bool bDone; // Set when the ray exits the volume

	RandomSequence RandSequence;

	void Init(float3 InWorldRayOrigin,
		float3 InWorldRayDirection,
		float InVolumeTMin,
		float InVolumeTMax,
		float2 RandSample)
	{
		// Set up DDA
		Iterator = HVPT_CreateTopLevelIterator(
			InWorldRayOrigin,
			InWorldRayDirection,
			InVolumeTMin,
			InVolumeTMax
		);

		RayOriginToSegmentDistance = InVolumeTMin;

		CurrentSegmentT = POSITIVE_INFINITY;
		SigmaMaj = 0.0f;
		MajorantTransmittance = 1.0f;
		bDone = false;

		RandSequence.SampleIndex = asuint(RandSample.x);
		RandSequence.SampleSeed = asuint(RandSample.y);
	}

	// Draw a new sample from the majorant grid
	// Advances DDA if sample exceeds current majorant segment
	FHVPT_MajorantSample Sample()
	{
		FHVPT_MajorantSample Sample = (FHVPT_MajorantSample)0;

		// No new samples can ever be drawn as the ray reached the end of its bounds
		if (bDone)
		{
			Sample.Distance = -1;
			return Sample;
		}

		int LoopGuard = 0;
		const int MaxSteps = 256;
		while (LoopGuard++ < MaxSteps)
		{
			// Progress to next segment if required
			if (CurrentSegmentT >= Iterator.GetWorldDeltaT())
			{
				bool bIsNextSegment = Iterator.Next();
				// Get new majorant
				// Majorant should never be less than 0 (and only equal to 0 in areas of empty space)
				uint Index = HVPT_GetTopLevelLinearIndex(Iterator);
				FMajorantData MajorantData = GetMajorantData(HVPT_OrthoGrid.MajorantGridBuffer[Index]);
				SigmaMaj = max(MajorantData.Majorant, 0.0f);

				if (!bIsNextSegment)
				{
					// There is not another segment to be processed by DDA so we cannot draw a sample EVER AGAIN
					bDone = true;
					// NOTE: Callers need to know the transmittance between the last sample and exiting the volume.
					// This will be stored in MajorantTransmittance when bDone is set to true
					Sample.Distance = -1;
					return Sample;
				}

				if (SigmaMaj.x == 0.0f)
				{
					// Zero-valued majorant means empty space - all coefficients are 0

					// Transmittance must still be accumulated (in case y/z components are not 0)
					MajorantTransmittance *= exp(-Iterator.GetWorldDeltaT() * SigmaMaj);

					// Advance to end of segment
					RayOriginToSegmentDistance += Iterator.GetWorldDeltaT();
					CurrentSegmentT = Iterator.GetWorldDeltaT();
					continue;
				}

				// Move to the beginning of the segment
				CurrentSegmentT = 0.0f;
			}
		
			// Sample current segment

			float u = RandomSequence_GenerateSample1D(RandSequence);
			// Draw sample from exponential PDF proportional to majorant transmission
			float SampleExponential = -log(1.0f - u) / SigmaMaj.x;

			// Get sample T position	
			float SampleDistance = CurrentSegmentT + SampleExponential;

			if (SampleDistance < Iterator.GetWorldDeltaT())
			{
				// We remained within segment, can use this as a sample location
				// Update transmittance to this location
				MajorantTransmittance *= exp(-SampleExponential * SigmaMaj);

				CurrentSegmentT = SampleDistance;
				break;
			}
			else // Sampled distance exceeds current segment
			{
				// Update transmittance and try to proceed to next segment
				// This is the transmittance from TMin to the end of the majorant segment
				float dt = Iterator.GetWorldDeltaT() - CurrentSegmentT;
				MajorantTransmittance *= exp(-dt * SigmaMaj);

				// DDA.Next() will be called on the next iteration of the loop
				RayOriginToSegmentDistance += Iterator.GetWorldDeltaT();
				CurrentSegmentT = Iterator.GetWorldDeltaT(); // Signals DDA to advance - Will get reset after DDA advances
			}
		}

		Sample.Distance = RayOriginToSegmentDistance + CurrentSegmentT;
		Sample.SigmaMaj = SigmaMaj;
		Sample.MajorantTransmittance = MajorantTransmittance;

		// Sample has been taken: reset transmittance
		MajorantTransmittance = 1.0f;

		return Sample;
	}
};


//
// --- TRACKING / TRANSMITTANCE METHODS
//

struct FHVPT_TrackingResult
{
	float Distance;
	float3 Transmittance; // TODO: float or float3?

	// Properties at sampling point
	float3 SigmaT;
	float3 SigmaS;
	float3 Emission;
	float PhaseG;
};

FHVPT_TrackingResult HVPT_CreateTrackingResult()
{
	FHVPT_TrackingResult Result = (FHVPT_TrackingResult)0;
	Result.Distance = POSITIVE_INFINITY;
	Result.Transmittance = 1.0f;
	return Result;
}


FHVPT_TrackingResult HVPT_DeltaTracking(FRayDesc Ray, inout RandomSequence RandSequence)
{
	FHVPT_MajorantSamplingContext SamplingContext;
	SamplingContext.Init(Ray.Origin, Ray.Direction, Ray.TMin, Ray.TMax, RandomSequence_GenerateSample2D(RandSequence));

	FHVPT_TrackingResult Result = HVPT_CreateTrackingResult();

	// Use delta tracking to sample the volume
	while (true)
	{
		FHVPT_MajorantSample Sample = SamplingContext.Sample();
		if (!Sample.IsValid())
		{
			break;
		}

		// Get volume properties at point
		float3 WorldPosition = Ray.Origin + Sample.Distance * Ray.Direction;
		FVolumeShadedResult Properties = HVPT_GetDensity(WorldPosition);
		Properties.SigmaT = min(Sample.SigmaMaj, Properties.SigmaT);

		// Determine if this is a null sample
		float3 NullProbability = max(0.0f, 1.0f - Properties.SigmaT / Sample.SigmaMaj);
		float RandValue = RandomSequence_GenerateSample1D(RandSequence);
		if (RandValue < max3(NullProbability.x, NullProbability.y, NullProbability.z))
		{
		}
		else
		{
			// Hit a real sample
			Result.Distance = Sample.Distance;

			Result.SigmaT = Properties.SigmaT;
			Result.SigmaS = Properties.SigmaSHG;
			Result.Emission = Properties.Emission;
			Result.PhaseG = Properties.PhaseG;

			break;
		}
	}

	return Result;
}

// Ratio tracking only gives the transmittance between two points
float3 HVPT_RatioTracking(FRayDesc Ray, inout RandomSequence RandSequence)
{
	float3 Transmittance = 1.0f;

	FHVPT_MajorantSamplingContext SamplingContext;
	SamplingContext.Init(Ray.Origin, Ray.Direction, Ray.TMin, Ray.TMax, RandomSequence_GenerateSample2D(RandSequence));
	
	while (true)
	{
		FHVPT_MajorantSample Sample = SamplingContext.Sample();
		if (!Sample.IsValid())
		{
			break;
		}

		// Get volume properties at point
		float3 WorldPosition = Ray.Origin + Sample.Distance * Ray.Direction;
		FVolumeShadedResult Properties = HVPT_GetDensity(WorldPosition);

		Properties.SigmaT = min(Sample.SigmaMaj, Properties.SigmaT);
		// Doing 1 - A/B gives negative values due to floating point rounding
		// Doing (B - A)/B instead avoids this issue
		Transmittance *= (Sample.SigmaMaj - Properties.SigmaT) / Sample.SigmaMaj;

		if (!any(Transmittance > 0))
		{
			break;
		}
	}

	return Transmittance;
}

float3 HVPT_RatioTracking_Majorant(FRayDesc Ray, inout RandomSequence RandSequence)
{
	float3 Transmittance = 1.0f;

	FHVPT_MajorantSamplingContext SamplingContext;
	SamplingContext.Init(Ray.Origin, Ray.Direction, Ray.TMin, Ray.TMax, RandomSequence_GenerateSample2D(RandSequence));
	
	while (true)
	{
		FHVPT_MajorantSample Sample = SamplingContext.Sample();
		if (!Sample.IsValid())
		{
			break;
		}

		Transmittance *= Sample.MajorantTransmittance;

		if (!any(Transmittance > 0))
		{
			break;
		}
	}

	return Transmittance;
}


// Fast approximate transmittance calculation that only visits cells
// in the top-level grid and uses the mean transmittance of the entire cell
float3 HVPT_TopLevelDDATransmittance(FRayDesc Ray)
{
	FHVPT_GridIterator TopLevelIterator = HVPT_CreateTopLevelIterator(Ray.Origin, Ray.Direction, Ray.TMin, Ray.TMax);
	float OpticalDepth = 0.0f;

	while (TopLevelIterator.Next())
	{
		uint TopLevelLinearIndex = HVPT_GetTopLevelLinearIndex(TopLevelIterator);
		float MeanExtinction = GetMajorantData(HVPT_OrthoGrid.MajorantGridBuffer[TopLevelLinearIndex]).Mean;

		// Accumulate optical depth instead of transmittance to save on exponential evaluations
		OpticalDepth += MeanExtinction * TopLevelIterator.GetWorldDeltaT();
		
		// -log(1e-3) ~= 6.9 - Empirically found to be quality / performance tradeoff
		if (OpticalDepth > 6.9f)
		{
			return 0.0f;
		}
	}

	return exp(-OpticalDepth);
}


float3 HVPT_DDATransmittance(FRayDesc Ray)
{
	FHVPT_GridIterator TopLevelIterator = HVPT_CreateTopLevelIterator(Ray.Origin, Ray.Direction, Ray.TMin, Ray.TMax);
	float OpticalDepth = 0.0f;

	while (TopLevelIterator.Next())
	{
		FHVPT_TopLevelGridData TopLevelData = HVPT_OrthoGrid.TopLevelGridBuffer[HVPT_GetTopLevelLinearIndex(TopLevelIterator)];
		uint FirstBottomLevelIndex = GetBottomLevelIndex(TopLevelData);

		if (IsBottomLevelAllocated(TopLevelData))
		{
			FHVPT_GridIterator BottomLevelIterator = HVPT_CreateBottomLevelIterator(
				TopLevelIterator.GetVoxelEntry(),
				TopLevelIterator.GetVoxelExit(),
				TopLevelIterator.GetDistanceScale(),
				GetBottomLevelVoxelResolution(TopLevelData)
			);
			while (BottomLevelIterator.Next())
			{
				uint BottomLevelIndex = HVPT_GetBottomLevelLinearIndex(BottomLevelIterator, FirstBottomLevelIndex);
				float3 Extinction = GetExtinction(HVPT_OrthoGrid.ExtinctionGridBuffer[BottomLevelIndex]);

				// Accumulate optical depth instead of transmittance to save on exponential evaluations
				OpticalDepth += max3(Extinction.x, Extinction.y, Extinction.z) * BottomLevelIterator.GetWorldDeltaT();
				
				// -log(1e-3) ~= 6.9 - Empirically found to be quality / performance tradeoff
				if (OpticalDepth > 6.9f)
				{
					return 0.0f;
				}
			}
		}
	}

	return exp(-OpticalDepth);
}

#endif