#ifndef TRACKINGUTILS_H
#define TRACKINGUTILS_H

#include "/Engine/Private/RayTracing/RayTracingCommon.ush"
#include "/Engine/Private/PathTracing/Volume/PathTracingVolumeCommon.ush"

#include "SamplingUtils.ush"

//
// --- TRACKING / TRANSMITTANCE METHODS
//

struct FHVPT_TrackingResult
{
	float Distance;
	float3 Transmittance; // TODO: float or float3?

	// Properties at sampling point
	float3 SigmaT;
	float3 SigmaS;
	float3 Emission;
	float PhaseG;
};

FHVPT_TrackingResult HVPT_CreateTrackingResult()
{
	FHVPT_TrackingResult Result = (FHVPT_TrackingResult)0;
	Result.Distance = POSITIVE_INFINITY;
	Result.Transmittance = 1.0f;
	return Result;
}


FHVPT_TrackingResult HVPT_DeltaTracking(FRayDesc Ray, inout RandomSequence RandSequence)
{
	FHVPT_MajorantSamplingContext SamplingContext;
	SamplingContext.Init(Ray.Origin, Ray.Direction, Ray.TMin, Ray.TMax, RandomSequence_GenerateSample2D(RandSequence));

	FHVPT_TrackingResult Result = HVPT_CreateTrackingResult();

	// Use delta tracking to sample the volume
	FHVPT_TrackingSample Sample = CreateTrackingSample();
	while (SamplingContext.Sample(Sample))
	{
		// Get volume properties at point
		float3 WorldPosition = Ray.Origin + Sample.Distance * Ray.Direction;
		FVolumeShadedResult Properties = HVPT_GetDensity(WorldPosition);
		Properties.SigmaT = min(Sample.Sigma, Properties.SigmaT);

		// Determine if this is a null sample
		float3 NullProbability = max(0.0f, 1.0f - Properties.SigmaT / Sample.Sigma);
		float RandValue = RandomSequence_GenerateSample1D(RandSequence);
		if (RandValue < max3(NullProbability.x, NullProbability.y, NullProbability.z))
		{
			// Continue to take another sample
		}
		else
		{
			// Hit a real sample
			Result.Distance = Sample.Distance;

			Result.SigmaT = Properties.SigmaT;
			Result.SigmaS = Properties.SigmaSHG;
			Result.Emission = Properties.Emission;
			Result.PhaseG = Properties.PhaseG;

			break;
		}
	}

	return Result;
}

FHVPT_TrackingResult HVPT_RegularTracking(FRayDesc Ray, inout RandomSequence RandSequence)
{
	FHVPT_RegularSamplingContext SamplingContext;
	SamplingContext.Init(Ray.Origin, Ray.Direction, Ray.TMin, Ray.TMax, RandomSequence_GenerateSample2D(RandSequence));

	FHVPT_TrackingResult Result = HVPT_CreateTrackingResult();

	// Use delta tracking to sample the volume
	FHVPT_TrackingSample Sample = CreateTrackingSample();
	if (SamplingContext.Sample(Sample))
	{
		// Get volume properties at point
		float3 WorldPosition = Ray.Origin + Sample.Distance * Ray.Direction;
		FVolumeShadedResult Properties = HVPT_GetDensity(WorldPosition);

		Result.Distance = Sample.Distance;

		Result.SigmaT = Properties.SigmaT;
		Result.SigmaS = Properties.SigmaSHG;
		Result.Emission = Properties.Emission;
		Result.PhaseG = Properties.PhaseG;
	}

	return Result;
}

// Ratio tracking only gives the transmittance between two points
float3 HVPT_RatioTracking(FRayDesc Ray, inout RandomSequence RandSequence)
{
	float3 Transmittance = 1.0f;

	FHVPT_MajorantSamplingContext SamplingContext;
	SamplingContext.Init(Ray.Origin, Ray.Direction, Ray.TMin, Ray.TMax, RandomSequence_GenerateSample2D(RandSequence));
	
	FHVPT_TrackingSample Sample = CreateTrackingSample();
	while (SamplingContext.Sample(Sample))
	{
		// Get volume properties at point
		float3 WorldPosition = Ray.Origin + Sample.Distance * Ray.Direction;
		FVolumeShadedResult Properties = HVPT_GetDensity(WorldPosition);

		Properties.SigmaT = min(Sample.Sigma, Properties.SigmaT);
		// Doing 1 - A/B gives negative values due to floating point rounding
		// Doing (B - A)/B instead avoids this issue
		Transmittance *= (Sample.Sigma - Properties.SigmaT) / Sample.Sigma;

		if (!any(Transmittance > 0))
		{
			break;
		}
	}

	return Transmittance;
}

float3 HVPT_RatioTracking_Majorant(FRayDesc Ray, inout RandomSequence RandSequence)
{
	float3 Transmittance = 1.0f;

	FHVPT_MajorantSamplingContext SamplingContext;
	SamplingContext.Init(Ray.Origin, Ray.Direction, Ray.TMin, Ray.TMax, RandomSequence_GenerateSample2D(RandSequence));
	
	FHVPT_TrackingSample Sample = CreateTrackingSample();
	while (SamplingContext.Sample(Sample))
	{
		Transmittance *= Sample.Transmittance;

		if (!any(Transmittance > 0))
		{
			break;
		}
	}

	return Transmittance;
}


// Fast approximate transmittance calculation that only visits cells
// in the top-level grid and uses the mean transmittance of the entire cell
float3 HVPT_TopLevelDDATransmittance(FRayDesc Ray)
{
	FHVPT_GridIterator TopLevelIterator = HVPT_CreateTopLevelIterator(Ray.Origin, Ray.Direction, Ray.TMin, Ray.TMax);
	float OpticalDepth = 0.0f;

	while (TopLevelIterator.Next())
	{
		uint TopLevelLinearIndex = HVPT_GetTopLevelLinearIndex(TopLevelIterator);
		float MeanExtinction = GetMajorantData(HVPT_OrthoGrid.MajorantGridBuffer[TopLevelLinearIndex]).Mean;

		// Accumulate optical depth instead of transmittance to save on exponential evaluations
		OpticalDepth += MeanExtinction * TopLevelIterator.GetWorldDeltaT();
		
		// -log(1e-3) ~= 6.9 - Empirically found to be quality / performance tradeoff
		if (OpticalDepth > 6.9f)
		{
			return 0.0f;
		}
	}

	return exp(-OpticalDepth);
}


float3 HVPT_DDATransmittance(FRayDesc Ray)
{
	FHVPT_GridIterator TopLevelIterator = HVPT_CreateTopLevelIterator(Ray.Origin, Ray.Direction, Ray.TMin, Ray.TMax);
	float OpticalDepth = 0.0f;

	while (TopLevelIterator.Next())
	{
		FHVPT_TopLevelGridData TopLevelData = HVPT_OrthoGrid.TopLevelGridBuffer[HVPT_GetTopLevelLinearIndex(TopLevelIterator)];
		uint FirstBottomLevelIndex = GetBottomLevelIndex(TopLevelData);

		if (IsBottomLevelAllocated(TopLevelData))
		{
			FHVPT_GridIterator BottomLevelIterator = HVPT_CreateBottomLevelIterator(
				TopLevelIterator.GetVoxelEntry(),
				TopLevelIterator.GetVoxelExit(),
				TopLevelIterator.GetDistanceScale(),
				GetBottomLevelVoxelResolution(TopLevelData)
			);
			while (BottomLevelIterator.Next())
			{
				uint BottomLevelIndex = HVPT_GetBottomLevelLinearIndex(BottomLevelIterator, FirstBottomLevelIndex);
				float3 Extinction = GetExtinction(HVPT_OrthoGrid.ExtinctionGridBuffer[BottomLevelIndex]);

				// Accumulate optical depth instead of transmittance to save on exponential evaluations
				OpticalDepth += max3(Extinction.x, Extinction.y, Extinction.z) * BottomLevelIterator.GetWorldDeltaT();
				
				// -log(1e-3) ~= 6.9 - Empirically found to be quality / performance tradeoff
				if (OpticalDepth > 6.9f)
				{
					return 0.0f;
				}
			}
		}
	}

	return exp(-OpticalDepth);
}

#endif