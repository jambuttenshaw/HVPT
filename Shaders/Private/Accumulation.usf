#include "/Engine/Private/Common.ush"

#ifndef THREADGROUP_SIZE_2D
#define THREADGROUP_SIZE_2D 1
#endif // THREADGROUP_SIZE_2D


// The number of samples that are accumulated in the history so far, so the new radiance texture's contribution can be correctly weighted
int NumAccumulatedSamples;

RWTexture2D<float4> RWTemporalAccumulationTexture_Lo;
RWTexture2D<float4> RWTemporalAccumulationTexture_Hi;

RWTexture2D<float3> RWRadianceTexture;
RWTexture2D<float2> RWFeatureTexture;


[numthreads(THREADGROUP_SIZE_2D, THREADGROUP_SIZE_2D, 1)]
void HVPT_AccumulateCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	int2 PixelCoord = DispatchThreadId.xy;

	if (any(PixelCoord >= View.ViewSizeAndInvSize.xy))
	{
		return;
	}

	float3 CurrentRadiance = RWRadianceTexture[PixelCoord];
	float2 CurrentFeature = RWFeatureTexture[PixelCoord];
	float4 CurrentVal = float4(CurrentRadiance, CurrentFeature.x);

	float4 SumLo = RWTemporalAccumulationTexture_Lo[PixelCoord];
	float4 SumHi = RWTemporalAccumulationTexture_Hi[PixelCoord];

	double Sum;
	float4 Output;

	for (uint i = 0; i < 4; i++)
	{
		Sum = asdouble(SumLo[i], SumHi[i]);
		Sum += (double) CurrentVal[i];
		asuint(Sum, SumLo[i], SumHi[i]);
		Output[i] = (float) (Sum / (double) (NumAccumulatedSamples + 1));
	}
	
	RWTemporalAccumulationTexture_Lo[PixelCoord] = SumLo;
	RWTemporalAccumulationTexture_Hi[PixelCoord] = SumHi;

	RWRadianceTexture[PixelCoord] = Output.xyz;
	RWFeatureTexture[PixelCoord] = float2(Output.w, CurrentFeature.y);
}
