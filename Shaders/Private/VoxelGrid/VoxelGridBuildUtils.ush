#ifndef VOXELGRIDBUILDUTILS_H
#define VOXELGRIDBUILDUTILS_H

#include "VoxelGridTypes.ush"
#include "/Engine/Private/MortonCode.ush"

// Utilities used for constructing voxel grids
// For accessing data in voxel grids in useful ways for path tracing, see VoxelGridUtils.ush

struct FMajorantData
{
	float Majorant;
};

FMajorantData CreateMajorantData()
{
	FMajorantData MajorantData;
	MajorantData.Majorant = 0.0;
	return MajorantData;
}

void UpdateMajorantData(inout FMajorantData MajorantData, float3 Value)
{
	float MaxValue = max(Value.x, max(Value.y, Value.z));
	MajorantData.Majorant = max(MajorantData.Majorant, MaxValue);
}

// Updating majorant data should occur for a single media
void UpdateMajorantData(inout FMajorantData MajorantData, FMajorantData Value)
{
	MajorantData.Majorant = max(MajorantData.Majorant, Value.Majorant);
}

// Merging majorant data should occur when mixing media
void MergeMajorantData(inout FMajorantData MajorantData, FMajorantData OverlappingMajorant)
{
	MajorantData.Majorant += OverlappingMajorant.Majorant;
}

FMajorantData GetMajorantData(FHVPT_MajorantGridData MajorantGridData)
{
	FMajorantData Data;
	Data.Majorant = asfloat(MajorantGridData.PackedData[0]);
	return Data;
}

void SetMajorantData(inout FHVPT_MajorantGridData MajorantGridData, FMajorantData MajorantData)
{
	MajorantGridData.PackedData[0] = asuint(MajorantData.Majorant);
}

float3 GetExtinction(FHVPT_GridData ExtinctionGridData)
{
	float3 Extinction = 0.0;
	Extinction.x = f16tof32(ExtinctionGridData.PackedData[0]);
	Extinction.y = f16tof32(ExtinctionGridData.PackedData[0] >> 16);
	Extinction.z = f16tof32(ExtinctionGridData.PackedData[1]);
	return Extinction;
}

void SetExtinction(inout FHVPT_GridData ExtinctionGridData, float3 Extinction)
{
	ExtinctionGridData.PackedData[0] = f32tof16(Extinction.x) | (f32tof16(Extinction.y) << 16);
	ExtinctionGridData.PackedData[1] = f32tof16(Extinction.z) | (ExtinctionGridData.PackedData[1] & 0xFFFF0000);
}

float3 GetEmission(FHVPT_GridData EmissionGridData)
{
	float3 Emission = 0.0;
	Emission.x = f16tof32(EmissionGridData.PackedData[0]);
	Emission.y = f16tof32(EmissionGridData.PackedData[0] >> 16);
	Emission.z = f16tof32(EmissionGridData.PackedData[1]);
	return Emission;
}

void SetEmission(inout FHVPT_GridData EmissionGridData, float3 Emission)
{
	EmissionGridData.PackedData[0] = f32tof16(Emission.x) | (f32tof16(Emission.y) << 16);
	EmissionGridData.PackedData[1] = f32tof16(Emission.z) | (EmissionGridData.PackedData[1] & 0xFFFF0000);
}

float3 GetScattering(FHVPT_GridData ScatteringGridData)
{
	float3 Scattering = 0.0;
	Scattering.x = f16tof32(ScatteringGridData.PackedData[0]);
	Scattering.y = f16tof32(ScatteringGridData.PackedData[0] >> 16);
	Scattering.z = f16tof32(ScatteringGridData.PackedData[1]);
	return Scattering;
}

void SetScattering(inout FHVPT_GridData ScatteringGridData, float3 Scattering)
{
	ScatteringGridData.PackedData[0] = f32tof16(Scattering.x) | (f32tof16(Scattering.y) << 16);
	ScatteringGridData.PackedData[1] = f32tof16(Scattering.z) | (ScatteringGridData.PackedData[1] & 0xFFFF0000);
}

float3 GetVelocity(FHVPT_GridData VelocityGridData)
{
	float3 Velocity = 0.0f;
	Velocity.x = f16tof32(VelocityGridData.PackedData[0]);
	Velocity.y = f16tof32(VelocityGridData.PackedData[0] >> 16);
	Velocity.z = f16tof32(VelocityGridData.PackedData[1]);
	return Velocity;
}

void SetVelocity(inout FHVPT_GridData VelocityGridData, float3 Velocity)
{
	VelocityGridData.PackedData[0] = f32tof16(Velocity.x) | (f32tof16(Velocity.y) << 16);
	VelocityGridData.PackedData[1] = f32tof16(Velocity.z) | (VelocityGridData.PackedData[1] & 0xFFFF0000);
}

FHVPT_TopLevelGridData CreateTopLevelGridData(uint PackedData)
{
	FHVPT_TopLevelGridData TopLevelGridData;
	TopLevelGridData.PackedData[0] = PackedData;
	return TopLevelGridData;
}

uint MortonEncode3(uint3 Voxel)
{
	return MortonCode3(Voxel.x) | MortonCode3(Voxel.y) << 1 | MortonCode3(Voxel.z) << 2;
}

uint3 MortonDecode3(uint Morton)
{
	uint3 Voxel = uint3(ReverseMortonCode3(Morton), ReverseMortonCode3(Morton >> 1), ReverseMortonCode3(Morton >> 2));
	return Voxel;
}

int GetLinearIndex(uint3 VoxelIndex, int3 TopLevelGridResolution)
{
	int SliceSize = TopLevelGridResolution.x * TopLevelGridResolution.y;

	return
		VoxelIndex.z * SliceSize +
		VoxelIndex.y * TopLevelGridResolution.x +
		VoxelIndex.x;
}

int3 GetVoxelIndex(int LinearIndex, int3 TopLevelGridResolution)
{
	int SliceSize = TopLevelGridResolution.x * TopLevelGridResolution.y;
	int SliceIndex = LinearIndex / SliceSize;
	int SliceRemainder = LinearIndex - SliceIndex * SliceSize;
	
	return int3(
		SliceRemainder % TopLevelGridResolution.x,
		SliceRemainder / TopLevelGridResolution.x,
		SliceIndex
	);
}

uint GetBottomLevelIndex(FHVPT_TopLevelGridData TopLevelGridData)
{
	// Maximum addressable space is equivalent to 1024 x 1024 x 512 top-level volume
	return TopLevelGridData.PackedData[0] >> 3;
}

void SetBottomLevelIndex(inout FHVPT_TopLevelGridData TopLevelGridData, uint BottomLevelIndex)
{
	uint Index = BottomLevelIndex;
	uint ResolutionExponent = TopLevelGridData.PackedData[0] & 0x7;
	TopLevelGridData.PackedData[0] = (Index << 3) | ResolutionExponent;
}

bool IsBottomLevelAllocated(FHVPT_TopLevelGridData TopLevelGridData)
{
	return GetBottomLevelIndex(TopLevelGridData) != EMPTY_VOXEL_INDEX;
}

bool IsBottomLevelEmpty(FHVPT_TopLevelGridData TopLevelGridData)
{
	uint ResolutionExponent = TopLevelGridData.PackedData[0] & 0x7;
	return (ResolutionExponent == 0u);
}

int3 GetBottomLevelVoxelResolution(FHVPT_TopLevelGridData TopLevelGridData)
{
	uint ResolutionExponent = TopLevelGridData.PackedData[0] & 0x7;
	int3 Resolution = ResolutionExponent;

	return Resolution;
}

void SetBottomLevelVoxelResolution(inout FHVPT_TopLevelGridData TopLevelGridData, int3 BottomLevelVoxelResolution)
{
	uint Index = GetBottomLevelIndex(TopLevelGridData);
	uint ResolutionExponent = BottomLevelVoxelResolution.x & 0x7;
	TopLevelGridData.PackedData[0] = (Index << 3) | ResolutionExponent;
}


// This is only used during voxel grid construction!! Before bottom level grid is allocated, the top level grid temporarily stores the voxel size
float GetVoxelSize(FHVPT_TopLevelGridData TopLevelGridData)
{
	return asfloat(TopLevelGridData.PackedData[0]);
}

// This is only used during voxel grid construction!! Before bottom level grid is allocated, the top level grid temporarily stores the voxel size
void SetVoxelSize(inout FHVPT_TopLevelGridData TopLevelGridData, float VoxelSize)
{
	TopLevelGridData.PackedData[0] = asint(VoxelSize);
}

#endif