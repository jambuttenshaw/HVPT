#include "VoxelGridTypes.ush"

#include "/Engine/Private/Common.ush"
#include "VoxelGridBuildUtils.ush"
#include "../Utils/FrustumUtils.ush"

#ifndef THREADGROUP_SIZE_3D
#define THREADGROUP_SIZE_3D 1
#endif

int3 TopLevelGridResolution;
float3 TopLevelGridWorldBoundsMin;
float3 TopLevelGridWorldBoundsMax;

float3 PrimitiveWorldBoundsMin;
float3 PrimitiveWorldBoundsMax;

void CalcVoxelBounds(float3 VoxelIndex, float3 GridResolution, float3 WorldBoundsMin, float3 WorldBoundsMax,
	inout float3 VoxelBoundsMin, inout float3 VoxelBoundsMax)
{
	float3 WorldBoundsExtent = WorldBoundsMax - WorldBoundsMin;
	VoxelBoundsMin = WorldBoundsMin + WorldBoundsExtent * (VoxelIndex / GridResolution);
	VoxelBoundsMax = WorldBoundsMin + WorldBoundsExtent * ((VoxelIndex + 1) / GridResolution);
}

void CalcTopLevelVoxelBounds(float3 VoxelIndex, inout float3 VoxelBoundsMin, inout float3 VoxelBoundsMax)
{
	CalcVoxelBounds(VoxelIndex, TopLevelGridResolution, TopLevelGridWorldBoundsMin, TopLevelGridWorldBoundsMax,
		VoxelBoundsMin, VoxelBoundsMax);
}

float3 GetVoxelCenter(float3 VoxelIndex, inout float3 VoxelBoundsMin, inout float3 VoxelBoundsMax)
{
	float3 TopLevelGridWorldBoundsExtent = TopLevelGridWorldBoundsMax - TopLevelGridWorldBoundsMin;
	return TopLevelGridWorldBoundsMin + TopLevelGridWorldBoundsExtent * ((VoxelIndex + 0.5) / TopLevelGridResolution);
}

bool PrimitiveIntersectsVoxel(float3 VoxelBoundsMin, float3 VoxelBoundsMax)
{
	if (any(PrimitiveWorldBoundsMin > VoxelBoundsMax) || any(VoxelBoundsMin > PrimitiveWorldBoundsMax))
	{
		return false;
	}

	return true;
}

float4 CreatePlane(
	float3 P_000,
	float3 P_100,
	float3 P_010
)
{
	float3 X = P_100 - P_000;
	float3 Y = P_010 - P_000;

	float3 N = normalize(cross(X, Y));
	float d = -dot(N, P_000);
	return float4(N, d);
}

float CalcSignedDistance(float3 P, float4 Plane)
{
	return dot(P, Plane.xyz) + Plane.w;
}

bool BoxIntersectsFrustum(float3 BoxOrigin, float3 BoxExtent, float4 Planes[5])
{
	for (int i = 0; i < 5; ++i)
	{
		float Distance = CalcSignedDistance(BoxOrigin, Planes[i]);
		float ProjectedExtent = dot(BoxExtent, abs(Planes[i].xyz));

		if (Distance > ProjectedExtent)
		{
			return false;
		}
	}

	return true;
}

bool BoxIntersectsViewFrustum(float3 BoxOrigin, float3 BoxExtent)
{
	float Epsilon = 1.0e-6;
#if HAS_INVERTED_Z_BUFFER
	float NearDepth = 1.0;
	float FarDepth = Epsilon;
#else
	float NearDepth = 0.0;
	float FarDepth = 1.0 - Epsilon;
#endif // HAS_INVERTED_Z_BUFFER

	FDFVector3 BoxWorldOrigin = DFPromote(BoxOrigin); // LWC_TODO
	float3 BoxTranslatedWorldOrigin = DFFastToTranslatedWorld(BoxWorldOrigin, PrimaryView.PreViewTranslation);

	// Project frustum vertices into world-space
	float4 Viewport = float4(0.0, 0.0, View.ViewSizeAndInvSize.xy);
	float3 W_000 = SvPositionToTranslatedWorld(float4(Viewport.xw, NearDepth, 1));
	float3 W_100 = SvPositionToTranslatedWorld(float4(Viewport.zw, NearDepth, 1));
	float3 W_010 = SvPositionToTranslatedWorld(float4(Viewport.xy, NearDepth, 1));
	float3 W_110 = SvPositionToTranslatedWorld(float4(Viewport.zy, NearDepth, 1));
	float3 W_001 = SvPositionToTranslatedWorld(float4(Viewport.xw, FarDepth, 1));
	float3 W_101 = SvPositionToTranslatedWorld(float4(Viewport.zw, FarDepth, 1));
	float3 W_011 = SvPositionToTranslatedWorld(float4(Viewport.xy, FarDepth, 1));
	float3 W_111 = SvPositionToTranslatedWorld(float4(Viewport.zy, FarDepth, 1));

	float4 Planes[5] =
	{
		// Front
		CreatePlane(W_000, W_010, W_100),
		// Back
		//CreatePlane(W_101, W_001, W_111),
		// +X
		CreatePlane(W_100, W_110, W_101),
		// +Y
		CreatePlane(W_010, W_011, W_110),
		// -X
		CreatePlane(W_000, W_001, W_010),
		// -Y
		CreatePlane(W_000, W_100, W_001)
	};

	return BoxIntersectsFrustum(BoxTranslatedWorldOrigin, BoxExtent, Planes);
}

float4x4 ViewToWorld;
float TanHalfFOV;
float NearPlaneDepth;
float FarPlaneDepth;

int3 VoxelDimensions;

RWStructuredBuffer<FHVPT_TopLevelGridData> RWTopLevelGridBuffer;


bool BoxIntersectsVoxel(float3 WorldBoxCenter, float WorldBoxRadius, uint3 VoxelIndex)
{
	float3 VoxelPosMin = VoxelIndex;
	float3 VoxelPosMax = (VoxelIndex + 1);

	float3 ViewPosMin = VoxelToView(VoxelPosMin, VoxelDimensions, NearPlaneDepth, FarPlaneDepth, TanHalfFOV);
	float3 ViewPosMax = VoxelToView(VoxelPosMax, VoxelDimensions, NearPlaneDepth, FarPlaneDepth, TanHalfFOV);

	float3 WorldPosMin = mul(float4(ViewPosMin, 1), ViewToWorld).xyz;
	float3 WorldPosMax = mul(float4(ViewPosMax, 1), ViewToWorld).xyz;

	float3 WorldPosCenter = (WorldPosMin + WorldPosMax) * 0.5;
	float WorldRadius = length((WorldPosMax - WorldPosMin) * 0.5);

	float DistanceToCenters = length(WorldBoxCenter - WorldPosCenter);
	float SumOfRadii = WorldBoxRadius + WorldRadius;
	return DistanceToCenters < SumOfRadii;
}

[numthreads(THREADGROUP_SIZE_3D, THREADGROUP_SIZE_3D, THREADGROUP_SIZE_3D)]
void HVPT_MarkTopLevelGridVoxelsForFrustumGridCS(
	uint3 DispatchThreadId : SV_DispatchThreadID
)
{
	uint3 VoxelIndex = DispatchThreadId;
	if (any(VoxelIndex >= TopLevelGridResolution))
	{
		return;
	}

	uint LinearIndex = GetLinearIndex(VoxelIndex, TopLevelGridResolution);
	FHVPT_TopLevelGridData TopLevelGridData = RWTopLevelGridBuffer[LinearIndex];
	uint3 VoxelResolution = GetBottomLevelVoxelResolution(TopLevelGridData);

	float3 WorldPrimitiveOrigin = (PrimitiveWorldBoundsMax + PrimitiveWorldBoundsMin) * 0.5;
	float3 WorldPrimitiveExtent = (PrimitiveWorldBoundsMax - PrimitiveWorldBoundsMin) * 0.5;
	if (BoxIntersectsVoxel(WorldPrimitiveOrigin, length(WorldPrimitiveExtent), VoxelIndex))
	{
		VoxelResolution = 4;
	}

	SetBottomLevelIndex(TopLevelGridData, EMPTY_VOXEL_INDEX);
	SetBottomLevelVoxelResolution(TopLevelGridData, VoxelResolution);
	RWTopLevelGridBuffer[LinearIndex] = TopLevelGridData;
}


int RasterTileVoxelResolution;
int MaxNumRasterTiles;

StructuredBuffer<FHVPT_TopLevelGridData> TopLevelGridBuffer;

RWBuffer<uint> RWRasterTileAllocatorBuffer;
RWStructuredBuffer<FRasterTileData> RWRasterTileBuffer;

[numthreads(THREADGROUP_SIZE_3D, THREADGROUP_SIZE_3D, THREADGROUP_SIZE_3D)]
void HVPT_GenerateRasterTilesCS(
	uint3 DispatchThreadId : SV_DispatchThreadID
)
{
	uint3 VoxelIndex = DispatchThreadId;
	if (any(VoxelIndex >= TopLevelGridResolution))
	{
		return;
	}

	int LinearIndex = GetLinearIndex(VoxelIndex, TopLevelGridResolution);
	if (!IsBottomLevelEmpty(TopLevelGridBuffer[LinearIndex]))
	{
		const int RasterTileCount = 1;

		uint RasterTileOffset;
		InterlockedAdd(RWRasterTileAllocatorBuffer[0], RasterTileCount, RasterTileOffset);

		// Prevent over allocation
		if (RasterTileOffset + RasterTileCount <= MaxNumRasterTiles)
		{
			RWRasterTileBuffer[RasterTileOffset].TopLevelGridLinearIndex = LinearIndex;
		}
		else
		{
			// Declare the buffer to be filled
			uint Dummy;
			InterlockedExchange(RWRasterTileAllocatorBuffer[0], MaxNumRasterTiles, Dummy);
		}
	}
}


int3 MaxDispatchThreadGroupsPerDimension;
Buffer<uint> RasterTileAllocatorBuffer;
RWBuffer<uint> RWRasterizeBottomLevelGridIndirectArgsBuffer;

uint3 GetGroupCountWrapped(uint TargetGroupCount)
{
	const uint WrappedGroupStride = 128;
	uint3 GroupCount = uint3(TargetGroupCount, 1, 1);

	if (GroupCount.x > MaxDispatchThreadGroupsPerDimension.x)
	{
		GroupCount.y = (GroupCount.x + WrappedGroupStride - 1) / WrappedGroupStride;
		GroupCount.x = WrappedGroupStride;
	}
	if (GroupCount.y > MaxDispatchThreadGroupsPerDimension.y)
	{
		GroupCount.z = (GroupCount.y + WrappedGroupStride - 1) / WrappedGroupStride;
		GroupCount.y = WrappedGroupStride;
	}

	return GroupCount;
}

[numthreads(1, 1, 1)]
void HVPT_SetRasterizeBottomLevelGridIndirectArgsCS()
{
	uint3 GroupCount = GetGroupCountWrapped(RasterTileAllocatorBuffer[0]);
	RWRasterizeBottomLevelGridIndirectArgsBuffer[0] = GroupCount.x;
	RWRasterizeBottomLevelGridIndirectArgsBuffer[1] = GroupCount.y;
	RWRasterizeBottomLevelGridIndirectArgsBuffer[2] = GroupCount.z;
}


float ShadingRateInFrustum;
float ShadingRateOutOfFrustum;
float MinVoxelSizeInFrustum;
float MinVoxelSizeOutOfFrustum;
int bUseProjectedPixelSize;


[numthreads(THREADGROUP_SIZE_3D, THREADGROUP_SIZE_3D, THREADGROUP_SIZE_3D)]
void HVPT_TopLevelGridCalculateVoxelSizeCS(
	uint3 DispatchThreadId : SV_DispatchThreadID
)
{
	uint3 VoxelIndex = DispatchThreadId;
	if (any(VoxelIndex >= TopLevelGridResolution))
	{
		return;
	}

	float3 VoxelBoundsMin;
	float3 VoxelBoundsMax;
	CalcTopLevelVoxelBounds(VoxelIndex, VoxelBoundsMin, VoxelBoundsMax);

	float3 WorldVoxelCenter = (VoxelBoundsMin + VoxelBoundsMax) * 0.5;
	float3 WorldVoxelExtent = (VoxelBoundsMax - VoxelBoundsMin) * 0.5;

	if (PrimitiveIntersectsVoxel(VoxelBoundsMin, VoxelBoundsMax))
	{
		float VoxelSize = MinVoxelSizeOutOfFrustum;
		float ShadingRate = ShadingRateOutOfFrustum;
		if (BoxIntersectsViewFrustum(WorldVoxelCenter, WorldVoxelExtent))
		{
			VoxelSize = MinVoxelSizeInFrustum;
			ShadingRate = ShadingRateInFrustum;
		}

		if (bUseProjectedPixelSize)
		{
			float2 TanHalfFOV = GetTanHalfFieldOfView();
			float HalfWidth = View.ViewSizeAndInvSize.x * 0.5;
			float PixelWidth = TanHalfFOV.x / HalfWidth;

			float3 WorldCameraOrigin = DFFastSubtractDemote(View.TranslatedWorldCameraOrigin, PrimaryView.PreViewTranslation);
			float Distance = max(GetDistanceToCameraFromViewVector(WorldVoxelCenter - WorldCameraOrigin) - length(WorldVoxelExtent), 0.0);
			float VoxelWidth = Distance * PixelWidth * ShadingRate;
			VoxelSize = max(VoxelWidth, VoxelSize);
		}

		// Store minimum voxel rate temporarily as the bottom-level index
		uint LinearIndex = GetLinearIndex(VoxelIndex, TopLevelGridResolution);
		if (IsBottomLevelAllocated(RWTopLevelGridBuffer[LinearIndex]))
		{
			float PrevVoxelSize = GetVoxelSize(RWTopLevelGridBuffer[LinearIndex]);
			VoxelSize = min(VoxelSize, PrevVoxelSize);
		}

		FHVPT_TopLevelGridData TopLevelGridData;
		{
			SetVoxelSize(TopLevelGridData, VoxelSize);
		}
		RWTopLevelGridBuffer[LinearIndex] = TopLevelGridData;
	}
}

int3 NextPowerOfTwo(int3 Value)
{
	Value -= 1;
	Value |= Value >> 1;
	Value |= Value >> 2;
	Value |= Value >> 4;
	Value |= Value >> 8;
	Value |= Value >> 16;
	Value += 1;

	return Value;
}

int MaxVoxelResolution;


[numthreads(THREADGROUP_SIZE_3D, THREADGROUP_SIZE_3D, THREADGROUP_SIZE_3D)]
void HVPT_AllocateBottomLevelGridCS(
	uint3 DispatchThreadId : SV_DispatchThreadID
)
{
	uint3 VoxelIndex = DispatchThreadId;
	if (any(VoxelIndex >= TopLevelGridResolution))
	{
		return;
	}

	uint LinearIndex = GetLinearIndex(VoxelIndex, TopLevelGridResolution);
	if (IsBottomLevelAllocated(RWTopLevelGridBuffer[LinearIndex]))
	{
		float VoxelSize = GetVoxelSize(RWTopLevelGridBuffer[LinearIndex]);

		float3 VoxelBoundsMin;
		float3 VoxelBoundsMax;
		CalcTopLevelVoxelBounds(VoxelIndex, VoxelBoundsMin, VoxelBoundsMax);

		// Calculate bottom-level voxel resolution and round to nearest power-of-two
		float3 VoxelBoundsExtent = VoxelBoundsMax - VoxelBoundsMin;
		int3 VoxelResolution = NextPowerOfTwo(ceil(VoxelBoundsExtent / VoxelSize));

		VoxelResolution = clamp(VoxelResolution, 1, MaxVoxelResolution);
		// Force regular sized dimensions so the permutation count is tractable for the allocator
		VoxelResolution = max(VoxelResolution.x, max(VoxelResolution.y, VoxelResolution.z));

		// Write the voxel contents
		FHVPT_TopLevelGridData TopLevelGridData = RWTopLevelGridBuffer[LinearIndex];
		{
			uint BottomLevelIndex = EMPTY_VOXEL_INDEX;

			SetBottomLevelIndex(TopLevelGridData, BottomLevelIndex);
			SetBottomLevelVoxelResolution(TopLevelGridData, VoxelResolution);
		}
		RWTopLevelGridBuffer[LinearIndex] = TopLevelGridData;
	}
}

StructuredBuffer<FHVPT_GridData> ExtinctionGridBuffer;
RWStructuredBuffer<FHVPT_GridData> RWMajorantVoxelGridBuffer;

[numthreads(THREADGROUP_SIZE_3D, THREADGROUP_SIZE_3D, THREADGROUP_SIZE_3D)]
void HVPT_BuildMajorantVoxelGridCS(
	uint3 DispatchThreadId : SV_DispatchThreadID
)
{
	int3 VoxelIndex = DispatchThreadId;
	if (any(VoxelIndex >= TopLevelGridResolution))
	{
		return;
	}

	FMajorantData MajorantData = CreateMajorantData();

	int LinearIndex = GetLinearIndex(VoxelIndex, TopLevelGridResolution);
	FHVPT_TopLevelGridData TopLevelGridData = TopLevelGridBuffer[LinearIndex];
	if (IsBottomLevelAllocated(TopLevelGridData))
	{
		int3 VoxelResolution = GetBottomLevelVoxelResolution(TopLevelGridData);
		int BottomLevelVoxelCount = VoxelResolution.x * VoxelResolution.y * VoxelResolution.z;

		for (int Index = 0; Index < BottomLevelVoxelCount; ++Index)
		{
			int BottomLevelIndex = GetBottomLevelIndex(TopLevelGridData) + Index;
			float3 Extinction = GetExtinction(ExtinctionGridBuffer[BottomLevelIndex]);
			UpdateMajorantData(MajorantData, Extinction);
		}
	}

	SetMajorantData(RWMajorantVoxelGridBuffer[LinearIndex], MajorantData);
}
