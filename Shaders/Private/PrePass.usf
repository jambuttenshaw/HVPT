
#include "VoxelGrid/VoxelGridTypes.ush"

#include "/Engine/Private/Common.ush"
#include "/Engine/Private/VelocityCommon.ush"
#include "/Engine/Private/DeferredShadingCommon.ush"

#include "/Engine/Shared/RayTracingDefinitions.h"
#include "/Engine/Shared/PathTracingDefinitions.h"

#include "/Engine/Private/RayTracing/RayTracingCommon.ush"
#include "/Engine/Private/PathTracing/PathTracingCommon.ush"

#include "/Engine/Private/ScreenPass.ush"

#include "/Engine/Private/PathTracing/Utilities/PathTracingRandomSequence.ush"
#include "/Engine/Private/PathTracing/Volume/PathTracingVolumeCommon.ush"

#include "Utils/PathTracingUtils.ush"
#include "Utils/TrackingUtils.ush"


SCREEN_PASS_TEXTURE_VIEWPORT(InputViewPort)
SCREEN_PASS_TEXTURE_VIEWPORT(OutputViewPort)

#ifndef WRITE_GBUFFER
#define WRITE_GBUFFER true
#endif

#ifndef DENSITY_GRADIENT_NORMAL
#define DENSITY_GRADIENT_NORMAL true
#endif

#ifndef TRANSMITTANCE_MODE
#define TRANSMITTANCE_MODE 1
#endif

#ifndef STOCHASTIC_GBUFFER_WRITES
#define STOCHASTIC_GBUFFER_WRITES true
#endif

#ifndef WRITE_VELOCITY
#define WRITE_VELOCITY true
#endif

// Uses a copy of the scene depth, that was made before writing HVPT into it
Texture2D<float> SceneDepthTexture_Copy;

uint TemporalSeed;

float Sharpness;

// The optical depth threshold at which volumetric fog will be composited
float FogComposition_OpticalDepth;

RWTexture2D<float2> RWFeatureTexture;
RWTexture2D<float4> RWVelocityTexture;

#if DEBUG_OUTPUT_ENABLED
RWTexture2D<float3> RWDebugTexture;
uint DebugFlags;
#endif


struct FHVPT_GBufferData
{
	float Transmittance;
	float InitialInteractionDistance;

	// We get the rest of the GBuffer data
	// for nearly free from calculating transmittance
	float3 Albedo;
	float DeviceZ;
	float3 Normal;
	float4 Velocity;
};


struct FHVPT_RayMarchingResult
{
	float Transmittance;
	float Distance_Sample; // Either: distance at which transmittance reaches zero OR a distance sample along the ray if transmittance never reaches 0
	float Distance_InitialInteraction; // Distance of the first scattering event along the ray
	bool bEscaped;
};

FHVPT_RayMarchingResult HVPT_CreateRayMarchingResult()
{
	FHVPT_RayMarchingResult Result = (FHVPT_RayMarchingResult) 0;
	Result.Transmittance = 1.0f;
	Result.Distance_Sample = POSITIVE_INFINITY;
	Result.Distance_InitialInteraction = POSITIVE_INFINITY;
	Result.bEscaped = false;
	return Result;
}

template<bool bWRSDistance = false, bool bRecordInitialInteraction = false>
FHVPT_RayMarchingResult HVPT_PrePass_RayMarchingTransmittance(FRayDesc Ray, inout RandomSequence RandSequence, float InitialInteraction_OpticalDepthThreshold = 1.0f)
{
	FHVPT_RayMarchingResult Result = HVPT_CreateRayMarchingResult();

	// For stochastically selecting a depth sample in the case that the ray is not fully extinguished
	// Only used when bWRSDistance is true
	float WeightSum = 0.0f;
	float DistanceTravelled = Ray.TMin;

	float OpticalDepth = 0.0f;

	FHVPT_GridIterator TopLevelIterator = HVPT_CreateTopLevelIterator(Ray.Origin, Ray.Direction, Ray.TMin, Ray.TMax);

	while (TopLevelIterator.Next())
	{
		FHVPT_TopLevelGridData TopLevelData = HVPT_OrthoGrid.TopLevelGridBuffer[HVPT_GetTopLevelLinearIndex(TopLevelIterator)];
		uint FirstBottomLevelIndex = GetBottomLevelIndex(TopLevelData);

		if (IsBottomLevelAllocated(TopLevelData))
		{
			FHVPT_GridIterator BottomLevelIterator = HVPT_CreateBottomLevelIterator(
				TopLevelIterator.GetVoxelEntry(),
				TopLevelIterator.GetVoxelExit(),
				TopLevelIterator.GetDistanceScale(),
				GetBottomLevelVoxelResolution(TopLevelData)
			);

			while (BottomLevelIterator.Next())
			{
				DistanceTravelled += BottomLevelIterator.GetWorldDeltaT();

				uint BottomLevelIndex = HVPT_GetBottomLevelLinearIndex(BottomLevelIterator, FirstBottomLevelIndex);
				float3 SpectralExtinction = GetExtinction(HVPT_OrthoGrid.ExtinctionGridBuffer[BottomLevelIndex]);
				float Extinction = max3(SpectralExtinction.x, SpectralExtinction.y, SpectralExtinction.z);

				// Accumulate optical depth instead of transmittance to save on exponential evaluations
				OpticalDepth += Extinction * BottomLevelIterator.GetWorldDeltaT();

				if (bRecordInitialInteraction && Result.Distance_InitialInteraction == POSITIVE_INFINITY)
				{
					if (OpticalDepth > InitialInteraction_OpticalDepthThreshold)
					{
						Result.Distance_InitialInteraction = DistanceTravelled;
					}
				}
				
				// -log(1e-3) ~= 6.9 - Empirically found to be quality / performance tradeoff
				if (OpticalDepth > 6.9f)
				{
					Result.bEscaped = false;
					Result.Distance_Sample = DistanceTravelled;
					Result.Transmittance = 0.0f;
					return Result;
				}
				if (bWRSDistance)
				{
					// Take a distance sample in this cell
					WeightSum += Extinction;
					if (RandomSequence_GenerateSample1D(RandSequence) * WeightSum < Extinction)
					{
						Result.Distance_Sample = DistanceTravelled;
					}
				}
			}
		}
		else
		{
			DistanceTravelled += TopLevelIterator.GetWorldDeltaT();
		}
	}

	Result.Transmittance = exp(-OpticalDepth);
	// TODO: I don't think this is reliable for rays where TMax was within the bounding box
	Result.bEscaped = Result.Transmittance > 0.0f;
	return Result;
}

float3 HVPT_CalculateNormal(float3 TranslatedWorldPos)
{
#if DENSITY_GRADIENT_NORMAL
	float3 Delta = (HVPT_GetTranslatedWorldPos(HVPT_OrthoGrid.TopLevelGridWorldBoundsMax) - HVPT_GetTranslatedWorldPos(HVPT_OrthoGrid.TopLevelGridWorldBoundsMin))
			/ HVPT_OrthoGrid.TopLevelGridResolution;
	float4 D = float4(Delta, 0.0f);

	// Use the gradient of the density field as a normal
	// Calculate the gradient using central differencing method
#define DENSITY(delta) Luminance(HVPT_GetOrthoVoxelGridDensity(TranslatedWorldPos + delta).SigmaT)
#define DENSITY_GRAD(delta) (DENSITY(-delta) - DENSITY(delta))

	float3 n = float3(
		DENSITY_GRAD(D.xww) / (2.0f * Delta.x),
		DENSITY_GRAD(D.wyw) / (2.0f * Delta.y),
		DENSITY_GRAD(D.wwz) / (2.0f * Delta.z)
	);

	// To avoid invalid normals, I just place the up vector in the case of a missing gradient vector.
	// As the normal is only assisting denoising, this doesn't appear to cause much in the way of visual artefacts.
	return all(n == 0.0f) ? float3(0, 0, 1) : normalize(n);
#else
	return 0.f;
#endif
}


float4 HVPT_CalculateEncodedScreenSpaceVelocity(float3 WorldSpacePosition)
{
	// Sample velocity from the volume
	float3 WorldSpaceVelocity = HVPT_GetVelocity(WorldSpacePosition);
	float3 PrevWorldSpacePosition = WorldSpacePosition - WorldSpaceVelocity;

	// Project velocity into screen space
	float4 ClipPos = mul(float4(WorldSpacePosition, 1), View.TranslatedWorldToClip);
	ClipPos /= ClipPos.w;

	// Using View.PrevTranslatedWorldToClip causes AA jitter in the volume
	// doing two matrix multiplications instead fixed that
	float4 PrevClipPos = mul(float4(PrevWorldSpacePosition, 1), View.TranslatedWorldToClip);
	PrevClipPos /= PrevClipPos.w;
	PrevClipPos = mul(PrevClipPos, View.ClipToPrevClip);

	float3 ScreenSpaceVelocity = Calculate3DVelocity(ClipPos, PrevClipPos);

	return EncodeVelocityToTexture(ScreenSpaceVelocity);
}


FHVPT_GBufferData HVPT_CalculateGBufferData(uint2 PixelCoord)
{
	uint LinearPixelIndex = PixelCoord.y * View.ViewSizeAndInvSize.x + PixelCoord.x;

	float DeviceZ = SceneDepthTexture_Copy.Load(uint3(PixelCoord, 0)).r;
	FRayDesc Ray = HVPT_CreateRayDesc<true>(PixelCoord, DeviceZ);

	RandomSequence RandSequence = (RandomSequence)0;
	RandomSequence_Initialize(RandSequence, LinearPixelIndex, TemporalSeed);

	FHVPT_GBufferData GBufferData = (FHVPT_GBufferData)0;
	GBufferData.Transmittance = 1.0f;
	GBufferData.InitialInteractionDistance = POSITIVE_INFINITY;

	// Ray must be bounded by the HV AABB for tracking to work correctly
	FVolumeIntersection VolIntersect = HVPT_Intersect(Ray.Origin, Ray.Direction, Ray.TMin, Ray.TMax);
	if (VolIntersect.HitVolume())
	{
		Ray.TMin = max(Ray.TMin, VolIntersect.VolumeTMin);
		Ray.TMax = min(Ray.TMax, VolIntersect.VolumeTMax);

#if TRANSMITTANCE_MODE == 0
		FHVPT_RayMarchingResult Result = HVPT_PrePass_RayMarchingTransmittance(Ray, RandSequence);
#elif TRANSMITTANCE_MODE == 1
		FHVPT_RayMarchingResult Result = HVPT_PrePass_RayMarchingTransmittance<true, true>(Ray, RandSequence, FogComposition_OpticalDepth);
#endif

		GBufferData.Transmittance = Result.Transmittance;
		GBufferData.InitialInteractionDistance = Result.Distance_InitialInteraction;

#if (TRANSMITTANCE_MODE == 1 && STOCHASTIC_GBUFFER_WRITES)
		float Rand = RandomSequence_GenerateSample1D(RandSequence);
		if (GBufferData.Transmittance == 0.0f || (Rand > GBufferData.Transmittance))
#else
		if (Result.Distance_Sample != POSITIVE_INFINITY)
#endif
		{
			float3 WorldPosition = Ray.Origin + Ray.Direction * Result.Distance_Sample;
			FVolumeShadedResult Properties = HVPT_GetDensity(WorldPosition);

			GBufferData.DeviceZ = ConvertToDeviceZ(Result.Distance_Sample);
			GBufferData.Albedo = saturate(Properties.SigmaSHG / Properties.SigmaT);
			GBufferData.Normal = HVPT_CalculateNormal(WorldPosition);

#if WRITE_VELOCITY
			GBufferData.Velocity = HVPT_CalculateEncodedScreenSpaceVelocity(WorldPosition);
#endif
		}
	}

	GBufferData.InitialInteractionDistance = min(GBufferData.InitialInteractionDistance, ConvertFromDeviceZ(GBufferData.DeviceZ));

	return GBufferData;
}


// Does not write to PIXELSHADEROUTPUT_MRT0: This will be the (indirect) radiance, which we will calculate in the subsequent radiance pass
void HVPT_PrePassPS(
	float2 InUV : TEXCOORD0,
	float4 SvPosition : SV_Position
#if WRITE_GBUFFER
#if PIXELSHADEROUTPUT_MRT1
	, out float4 OutTarget1 : SV_Target1
#endif
#if PIXELSHADEROUTPUT_MRT2
	, out float4 OutTarget2 : SV_Target2
#endif
#if PIXELSHADEROUTPUT_MRT3
	, out float4 OutTarget3 : SV_Target3
#endif
#if PIXELSHADEROUTPUT_MRT4
	, out float4 OutTarget4 : SV_Target4
#endif
#if PIXELSHADEROUTPUT_MRT5
	, out float4 OutTarget5 : SV_Target5
#endif
#if PIXELSHADEROUTPUT_MRT6
	, out float4 OutTarget6 : SV_Target6
#endif
#if PIXELSHADEROUTPUT_MRT7
	, out float4 OutTarget7 : SV_Target7
#endif
	, out float OutDepth : SV_Depth
#endif // WRITE_GBUFFER
)
{
	uint2 PixelPos = min(SvPosition.xy + InputViewPort_ViewportMin, InputViewPort_ViewportMax - 1);
	FHVPT_GBufferData VolumeGBufferData = HVPT_CalculateGBufferData(PixelPos);

	RWFeatureTexture[PixelPos] = float2(VolumeGBufferData.Transmittance, VolumeGBufferData.InitialInteractionDistance);

	if (VolumeGBufferData.DeviceZ == 0.0f)
	{
		// No volume exists for this pixel
		discard;
	}

#if WRITE_VELOCITY
	RWVelocityTexture[PixelPos] = VolumeGBufferData.Velocity;
#endif

#if WRITE_GBUFFER

	// Encode into GBuffer data
	FGBufferData GBufferData = (FGBufferData) 0;
	GBufferData.Depth = VolumeGBufferData.DeviceZ;
	GBufferData.WorldNormal = VolumeGBufferData.Normal;
	GBufferData.DiffuseColor = VolumeGBufferData.Albedo;
	GBufferData.SpecularColor = 0.0f;
	GBufferData.BaseColor = VolumeGBufferData.Albedo;
	// Turning up the metallic has a sharpening effect on the volume after denoising with DLSS-RR
	GBufferData.Metallic = Sharpness;
	GBufferData.Specular = 0.0f;
	// Low roughness makes the volume less temporally stable - I assume DLSS is treating it as more 'reflective' and thus more view-dependent
	GBufferData.Roughness = 1.0f;
	// TODO: Compare effect of using unlit vs medium
	GBufferData.ShadingModelID = SHADINGMODELID_MEDIUM;
	// Written to texture via UAV
	GBufferData.Velocity = 0.0f;

	// Encode data into MRT format
	FPixelShaderOut PSOut = (FPixelShaderOut) 0;
	EncodeGBufferToMRT(PSOut, GBufferData, /* QuantizationBias = */0.0f);

	OutDepth = GBufferData.Depth;
	
#if PIXELSHADEROUTPUT_MRT1
	OutTarget1 = PSOut.MRT[1];
#endif
#if PIXELSHADEROUTPUT_MRT2
	OutTarget2 = PSOut.MRT[2];
#endif
#if PIXELSHADEROUTPUT_MRT3
	OutTarget3 = PSOut.MRT[3];
#endif
#if PIXELSHADEROUTPUT_MRT4
	OutTarget4 = PSOut.MRT[4];
#endif
#if PIXELSHADEROUTPUT_MRT5
	OutTarget5 = PSOut.MRT[5];
#endif
#if PIXELSHADEROUTPUT_MRT6
	OutTarget6 = PSOut.MRT[6];
#endif
#if PIXELSHADEROUTPUT_MRT7
	OutTarget7 = PSOut.MRT[7];
#endif

#endif // WRITE_GBUFFER
}
